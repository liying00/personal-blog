{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/浣跨敤hexo+github鎼缓涓汉鍗氬.md","hash":"034772033efe79a2380744f8fe3d38f95cb55a57","modified":1609939054000},{"_id":"source/.DS_Store","hash":"b7eaa6212a25e348e8e4cbec3faff8c11a3b26c6","modified":1612097376000},{"_id":"source/_posts/React.md","hash":"7e31691a3f7a8dc3d27a0c1ef9b525c22231bf1f","modified":1612097800000},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1609208406000},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1609208406000},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1609208406000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1609208406000},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1609208406000},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1609208406000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1609208406000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1609208406000},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1609208406000},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1609208406000},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1609208406000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1609208406000},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1609208406000},{"_id":"themes/next/_config.yml","hash":"ccd41ed5fc3027f81834c30fe4b67c0dac742dea","modified":1609208406000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1609208406000},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1609208406000},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1609208406000},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1609208406000},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1609208406000},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1609208406000},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1609208406000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1609208406000},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1609208406000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1609208406000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1609208406000},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1609208406000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1609208406000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1609208406000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1609208406000},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1609208406000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1609208406000},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1609208406000},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1609208406000},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1609938500000},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1609208406000},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1609208406000},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1609208406000},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1609938494000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1609208406000},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1609208406000},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1609208406000},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1609208406000},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1609208406000},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1609208406000},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1609208406000},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1609208406000},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1609208406000},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1609208406000},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1609208406000},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1609208406000},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1609208406000},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1609208406000},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1609208406000},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1609208406000},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1609208406000},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1609208406000},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1609208406000},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1609208406000},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1609208406000},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1609208406000},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1609208406000},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1609208406000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1609208406000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1609208406000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1609208406000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1609208406000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1609208406000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1609208406000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1609208406000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1609208406000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1609208406000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1609208406000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1609208406000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1609208406000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1609208406000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1609208406000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1609208406000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1609208406000},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1609208406000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1609208406000},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1609208406000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1609208406000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1609208406000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1609208406000},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1609208406000},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1609208406000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1609208406000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1609208406000},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1609208406000},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1609208406000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1609208406000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1609208406000},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1609208406000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1609208406000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1609208406000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1609208406000},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1609208406000},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1609208406000},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1609208406000},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1609208406000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1609208406000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1609208406000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1609208406000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1609208406000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1609208406000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1609208406000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1609208406000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1609208406000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1609208406000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1609208406000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1609208406000},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1609208406000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1609208406000},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1609208406000},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1609208406000},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1609208406000},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1609208406000},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1609208406000},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1609208406000},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1609208406000},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1609208406000},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1609208406000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1609208406000},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1609208406000},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1609208406000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1609208406000},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1609208406000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1609208406000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1609208406000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1609208406000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1609208406000},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1609208406000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1609208406000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1609208406000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1609208406000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1609208406000},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1609208406000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1609208406000},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1609208406000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1609208406000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1609208406000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1609208406000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1609208406000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1609208406000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1609208406000},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1609208406000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1609208406000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1609208406000},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1609208406000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1609208406000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1609208406000},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1609208406000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1609208406000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1609208406000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1609208406000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1609208406000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1609208406000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1609208406000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1609208406000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1609208406000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1609208406000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1609208406000},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1609208406000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1609208406000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1609208406000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1609208406000},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1609208406000},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1609208406000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1609208406000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1609208406000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1609208406000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1609208406000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1609208406000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1609208406000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1609208406000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1609208406000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1609208406000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1609208406000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1609208406000},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1609208406000},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1609208406000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1609208406000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1609208406000},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1609208406000},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1609208406000},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1609208406000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1609208406000},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1609208406000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1609208406000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1609208406000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1609208406000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1609208406000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1609208406000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1609208406000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1609208406000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1609208406000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1609208406000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1609208406000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1609208406000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1609208406000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1609208406000},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1609208406000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1609208406000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1609208406000},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1609208406000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1609208406000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1609208406000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1609208406000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1609208406000},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1609208406000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1609208406000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1609208406000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1609208406000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1609208406000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1609208406000},{"_id":"public/2021/01/06/浣跨敤hexo+github鎼缓涓汉鍗氬/index.html","hash":"a7bb038fd647cf610976af8b8b09635513b0001f","modified":1652774743301},{"_id":"public/archives/index.html","hash":"7883780b2a1d7c8a188e196432de1e4c3e0d8071","modified":1652774743301},{"_id":"public/archives/2021/index.html","hash":"d304778a740cec32d8d0842068e118e8a72266f3","modified":1652774743301},{"_id":"public/archives/2021/01/index.html","hash":"88540827b5ac50a9623f1abbb923ccce96df156c","modified":1652774743301},{"_id":"public/2021/01/31/React/index.html","hash":"dfe920d41062ae6104787ac86e4a80119d73cfa7","modified":1652774743301},{"_id":"public/index.html","hash":"c3483f987c7153979ef88039fc7f014d61ac8e30","modified":1652774743301},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1652774743301},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1652774743301},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1652774743301},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1652774743301},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1652774743301},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1652774743301},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1652774743301},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1652774743301},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1652774743301},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1652774743301},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1652774743301},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1652774743301},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1652774743301},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1652774743301},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1652774743301},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1652774743301},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1652774743301},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1652774743301},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1652774743301},{"_id":"public/css/main.css","hash":"e2ec4f28fe4952bd643d23bfd56d857758d65b2f","modified":1652774743301},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1652774743301},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1652774743301},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1652774743301},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1652774743301},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1652774743301},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1652774743301},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1652774743301},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1652774743301},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1652774743301},{"_id":"source/_posts/小程序技能必备-1.md","hash":"f62283185fedf75a60f6d536b6d895eb66071917","modified":1652775529003},{"_id":"source/_posts/使用hexo+github搭建个人博客.md","hash":"034772033efe79a2380744f8fe3d38f95cb55a57","modified":1609939054000},{"_id":"source/_posts/常用的JavaScript方法封装2.md","hash":"d8e49469cfe5fa5f595c2f62618087008dce47d1","modified":1652776330790},{"_id":"source/_posts/常用的JavaScript方法封装.md","hash":"35d555be94568a47bf6e8eda5639fada3fb663b5","modified":1652776462063}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"React","date":"2021-01-31T13:09:39.000Z","_content":"\n#### 组件生命周期\n\n一个组件类由extends Component 创建，并且提供一个render方法以及其他可选的生命周期函数、组件相关事件定义\n\n<pre>getInitialState</pre>\n初始化 this.state的值，只在组件装载之前调用一次。\nEs6： 构造函数中 (construcor)进行初始化\n\n<pre>getDefaultProps</pre>\n组件创建时调用一次并缓存返回的对象（在初始化之前就调用）\nEs6：直接定义defaultProps这个类属性来替代，\n         Counter.defaultProps = { initialCount: 0 };\n\n<pre>Render</pre>\n组装生成这个组件的HTML结构，也可以返回null或false\n\n\n\n#### 生命周期函数\n\n##### 装载组件触发\n\n<pre>componentWillMount </pre>\n在装载之前调用一次，在render之前调用，可以再这里调用setState改变状态，并且不会导致额外调用一次 render\n\n<pre>componentDidMount</pre>\n在装载完成以后调用一次，在render之后调用，通过ReactDOM.findDOMNode(this)获取组件DOM节点\n\n##### 更新组件触发\n\n这些不会在首次render调用\n<pre>componentWillReceiveProps\nshouldComponentUpdate\ncomponentWillUpdate\ncomponentDidUpdate</pre>\n\n##### 卸载组件触发\n<pre>componentWillUnmount</pre>\n\n#### 事件处理\n\n#####  绑定事件\n<pre>this.handleClick.bind(this)</pre>\n要显式调用bind(this)将事件函数上下文绑定在组件实例上，尽量使用显式容易理解的js代码\n\n##### 合成事件 \n消除了IE与W3C标准之前的兼容问题\n合成事件已时间委托方式绑定在组件最上层 ，并且在组件卸载时候自动销毁绑定事件。\n\n##### 原生事件\n比如在componentDidMount方法里面通过addEventListener绑定的事件就是浏览器原生事件\n\n##### 参数传递\n<pre>this.handleClick.bind>this.handleClick.bind ( this, 'extra param')</pre>\n\n\n##### DOM操作\nReactDOM.render组件返回组件实例（无状态的返回null）\n\n<pre>findDOMNode()\nimport { findDOMNode } from 'react-dom';\n// Inside Component class\ncomponentDidMound() {\n  const el = findDOMNode(this);\n}\n//findDOMNode() 不能用在无状态组件上。</pre>\n\n##### Refs\n通过引用DOM元素上面设置一个ref属性指定一个名称，然后通过this.refs.name来访问对应的Dom元素\n\n如果ref设置在原生HTML元素上，拿到的就是DOM元素，如果设置在自定义组件上，拿到就是组件实例，通过findDOMNode来拿到组件的DOM元素。\n\n##### 小结Ref：\n1.  可以使用ref到的组件定义的任何公共方法，比如 this.refs.myTypehead.reset()\n2.  Refs是访问到组件内部DOM节点唯一可靠的方法\n3.  Refs会自动销毁对子组件的引用（当子组件删除时）\n4.  不要在render或者render之前访问refs\n5.  不要滥用 refs \n\n\n##### This.props.children\n组件标签里面包含的子元素会通过props.children传递进来\n一般可以直接将这个属性作为父组件的子元素render\n<pre>Const Parent=(props)=><div>{props.children}</div></pre>\n\nprops.children通常是一个组件对象的数组，但是当只有一个元素的时候，props.children将是这个唯一的子元素，而不是数组了。\n\n##### 组件间通信\n父子组件间通信\n\n通过props属性传递，在父组件给子组件设置props，然后子组件通过props访问到父组件的数据/方法，搭建了父子组件间通信的桥梁。\n\n##### Flux\n\n**React：MVC中V\nFlux：M和C\nFlux(四部分)           Action -> Dispatcher -> Store -> View**\n\n\n1.  The dispatcher 处理动作分发，维护store之间的依赖关系\n2.  The stores 数据和逻辑部分\n3.  The views React组件，这一层可以看做controller-views,作为视图同时响应用户交互\n4.  The actions 提供给dispatcher传递数据给store\n\n##### 单项数据流\n\n\n流程如下：\n首先要有 action，通过定义一些 action creator 方法根据需要创建 Action 提供给 dispatcher\nView 层通过用户交互（比如 onClick）会触发 Action\nDispatcher 会分发触发的 Action 给所有注册的 Store 的回调函数\nStore 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了\nView 会监听这个 change 事件，拿到对应的新数据并调用 setState 更新组件 UI\n所有的状态都由 Store 来维护，通过 Action 传递数据，构成了如上所述的单向数据流循环。\n\n\n# Redux\n\n## 三个基本原则\n1.  整个应用只有唯一一个可信数据源，也就是只有一个 Store\n2.  State 只能通过触发 Action 来更改\n3.  State 的更改必须写成纯函数，也就是每次更改总是返回一个新的 State，在 Redux 里这种函数称为 Reducer\n\n### Actions\n\nactions包含{type,payload}的对象，type是一个常量用来标识动作类型，payload是这个动作携带的数据。Action需要通过store.dispatch()方法来发送。\n\n一般来说，会使用函数（Action Creators）来生成 action，这样会有更大的灵活性，Action Creators 是一个 pure function，它最后会返回一个 action 对象：\n\nfunction addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n所以现在要触发一个动作只要调用 dispatch: dispatch(addTodo(text))\n\n### Reducers \n\nReducers用来处理Action触发的对状态树的更改。\n\n一个reducers函数会接受oldState和action两个参数，返回一个新的state:(oldState,action)=>newState。\n\nRedux提供一个工具函数combineReducers简化reducer合并\n\nimport { combineReducers } from 'redux';\n\nconst someApp = combineReducers({\n  a: reducerA,\n  b: reducerB\n});\n如果reducer函数名字和字段名字相同，利用es6的destructuring可以简化成 combineReducers({a,b})\n\n### Store\nStore负责连接Action和Reducer。\n作用：\n\t1. Hold 住整个应用的 State 状态树\n\t2. 提供一个 getState() 方法获取 State\n\t3. 提供一个 dispatch() 方法发送 action 更改 State\n\t4. 提供一个 subscribe() 方法注册回调函数监听 State 的更改\n\n创建一个 Store 很容易，将 root reducer 函数传递给 createStore 方法即可：\n\nimport { createStore } from 'redux';\nimport someApp from './reducers';\nlet store = createStore(someApp);\n\n// 你也可以额外指定一个初始 State（initialState），这对于服务端渲染很有用\n// let store = createStore(someApp, window.STATE_FROM_SERVER);\n\n\n拿到了store.dispatch,用来分发action\nstore.dispatch({ type: 'CHANGE_A' });\nstore.dispatch({ type: 'CHANGE_B', payload: 'Modified b' });\n\n### 在 React 应用中使用 Redux\n\n和 Flux 类似，Redux 也是需要注册一个回调函数 store.subscribe(listener) 来获取 State 的更新，然后我们要在 listener 里面调用 setState() 来更新 React 组件。\n\n<Provider>\n<Provider> 作为一个容器组件，用来接受 Store，并且让 Store 对子组件可用，用法如下：\n\nimport { render } from 'react-dom';\nimport { Provider } from 'react-redux';\nimport App from './app';\n\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n这时候 <Provider> 里面的子组件 <App /> 才可以使用 connect 方法关联 store。\n\n### Connect\n\nconnect() 这个方法略微复杂一点，主要是因为它的用法非常灵活：connect([mapStateToProps], mapDispatchToProps], [mergeProps], [options])，它最多接受4个参数，都是可选的，并且这个方法调用会返回另一个函数，这个返回的函数来接受一个组件类作为参数，最后才返回一个和 Redux store 关联起来的新组件，类似这样：\n\nclass App extends Component { ... }\nexport default connect()(App);\n这样就可以在 App 这个组件里面通过 props 拿到 Store 的 dispatch 方法，但是注意现在的 App 没有监听 Store 的状态更改，如果要监听 Store 的状态更改，必须要指定 mapStateToProps 参数。\n\n参数 \n\t• [mapStateToProps(state, [ownProps]): stateProps]: \n\t\n\t第一个可选参数是一个函数，只有指定了这个参数，这个关联（connected）组件才会监听 Redux Store 的更新，每次更新都会调用 mapStateToProps 这个函数，返回一个字面量对象将会合并到组件的 props 属性。 ownProps 是可选的第二个参数，它是传递给组件的 props，当组件获取到新的 props 时，ownProps 都会拿到这个值并且执行 mapStateToProps 这个函数。\n\t\n\t• [mapDispatchProps(dispatch, [ownProps]): dispatchProps]:\n\t\n\t 这个函数用来指定如何传递 dispatch 给组件，在这个函数里面直接 dispatch action creator，返回一个字面量对象将会合并到组件的 props 属性，这样关联组件可以直接通过 props 调用到 action， Redux 提供了一个 bindActionCreators() 辅助函数来简化这种写法。 如果省略这个参数，默认直接把 dispatch 作为 props 传入。ownProps 作用同上。\n\t\n\t\n\t\n表单\n\n表单元素有这么几种属于状态的属性：\n\n\t· value，对应 <input> 和 <textarea> 所有\n\t· checked，对应类型为 checkbox 和 radio 的 <input> 所有\n\t· selected，对应 <option> 所有\n\t\n受控组件\n\t\n用onchange事件改变状态属性\n\n非受控组件\n\n如果你想要给“状态属性”设置默认值，就要用 React 提供的特殊属性 defaultValue，对于 checked 会有 defaultChecked，<option> 也是使用 defaultValue。\n\n\n<select>\n\n在 HTML 中 <select> 标签指定选中项都是通过对应 <option> 的 selected 属性来做的，但是在 React 修改成统一使用 value。\n\n\n### 总结\n\n#### 关于 Store：\n\n1. 整个应用只有一个唯一的 Store\n2.  Store 对应的状态树（State），由调用一个 reducer 函数（root reducer）生成\n3.  状态树上的每个字段都可以进一步由不同的 reducer 函数生成\n4.  Store 包含了几个方法比如 dispatch, getState 来处理数据流\n5.  Store 的状态树只能由 dispatch(action) 来触发更改\n\n#### Redux 的数据流：\n\n1. action 是一个包含 { type, payload } 的对象\n2.  reducer 函数通过 store.dispatch(action) 触发\n3.  reducer 函数接受 (state, action) 两个参数，返回一个新的 state\n4. reducer 函数判断 action.type 然后处理对应的 action.payload 数据来更新状态树\n5.  所以对于整个应用来说，一个 Store 就对应一个 UI 快照，服务器端渲染就简化成了在服务器端初始化 Store，将 Store 传入应用的根组件，针对根组件调用 renderToString 就将整个应用输出成包含了初始化数据的 HTML。 \n\n#### React-router\n\nreact-router 通过一种声明式的方式匹配不同路由决定在页面上展示不同的组件，并且通过 props 将路由信息传递给组件使用，所以只要路由变更，props 就会变化，触发组件 re-render。\n\n\n#### Reducer\n\nStore 是由 reducer 产生的，所以 reducer 实际上反映了 Store 的状态树结构。\n\n./reducers/index.js\n\n<pre>import listReducer from './list';\nimport itemReducer from './item';\n\nexport default function rootReducer(state = {}, action) {\n  return {\n    list: listReducer(state.list, action),\n    item: itemReducer(state.item, action)\n  };\n  }</pre>\nrootReducer 的 state 参数就是整个 Store 的状态树，状态树下的每个字段对应也可以有自己的 reducer，所以这里引入了 listReducer 和 itemReducer，可以看到这两个 reducer 的 state 参数就只是整个状态树上对应的 list 和 item 字段。\n\n具体到 ./reducers/list.js\n\n<pre>const initialState = [];\n\nexport default function listReducer(state = initialState, action) {\n  switch(action.type) {\n  case 'FETCH_LIST_SUCCESS': return [...action.payload];\n  default: return state;\n  }\n  }</pre>\nlist 就是一个包含 items 的简单数组，可能类似这种结构：[{ id: 0, name: 'first item'}, {id: 1, name: 'second item'}]，从 'FETCH_LIST_SUCCESS' 的 action.payload 获得。\n\n然后是 ./reducers/item.js，处理获取到的 item 数据\n\n<pre>const initialState = {};\n\nexport default function listReducer(state = initialState, action) {\n  switch(action.type) {\n  case 'FETCH_ITEM_SUCCESS': return [...action.payload];\n  default: return state;\n  }\n  }</pre>\n\n\n#### Action\n对应的应该要有两个 action 来获取 list 和 item，触发 reducer 更改 Store，这里我们定义 fetchList 和 fetchItem 两个 action。\n\n./actions/index.js\n\n<pre>import fetch from 'isomorphic-fetch';\n\nexport function fetchList() {\n  return (dispatch) => {\n    return fetch('/api/list')\n        .then(res => res.json())\n        .then(json => dispatch({ type: 'FETCH_LIST_SUCCESS', payload: json }));\n  }\n}\n\nexport function fetchItem(id) {\n  return (dispatch) => {\n    if (!id) return Promise.resolve();\n    return fetch(`/api/item/${id}`)\n        .then(res => res.json())\n        .then(json => dispatch({ type: 'FETCH_ITEM_SUCCESS', payload: json }));\n  }\n  }</pre>\nisomorphic-fetch 是一个前后端通用的 Ajax 实现，前后端要共享代码这点很重要。\n\n另外因为涉及到异步请求，这里的 action 用到了 thunk，也就是函数，redux 通过 thunk-middleware 来处理这类 action，把函数当作普通的 action dispatch 就好了，比如 dispatch(fetchList())\n\n\n#### Store\n我们用一个独立的 ./store.js，配置（比如 Apply Middleware）生成 Store\n\n<pre>import { createStore } from 'redux';\nimport rootReducer from './reducers';\n\n// Apply middleware here\n// ...\n\nexport default function configureStore(initialState) {\n  const store = createStore(rootReducer, initialState);\n  return store;\n  }</pre>\n\n\n\n#### react-redux\n实现 List ，Item 组件，然后把 Redux 和 React 组件关联起来\n./app.js\n\n<pre>\nimport React from 'react';\nimport { render } from 'react-dom';\nimport { Router } from 'react-router';\nimport createBrowserHistory from 'history/lib/createBrowserHistory';\nimport { Provider } from 'react-redux';\nimport routes from './routes';\nimport configureStore from './store';\n\n// __INITIAL_STATE__来自服务器端渲染\n</pre>\n<code>\nconst initialState = window.__INITIAL_STATE__;\nconst store = configureStore(initialState);\nconst Root = (props) => {\n  return (\n <pre>     <Provider store={store}></pre>\n   <pre>     <Router history={createBrowserHistory()}></pre>\n   <pre>       {routes}</pre>\n   <pre>     </Router></pre>\n   <pre>   </Provider></pre>\n  );\n}\n\nrender(<Root />, document.getElementById('root'));</code>\n\n##### 到此 客户端部分结束\n\n\n#### Server Rendering\n获取数据调用action,routes在服务端处理参考 react-router server rendering ，在服务器端用一个match方法将拿到的request url 匹配到我们之前定义的routes，解析成和客户端一致的props对象传递给组件。\n\n服务器端渲染部分可以直接通过共用客户端 store.dispatch(action) 来统一获取 Store 数据。另外注意 renderFullPage 生成的页面 HTML 在 React 组件 mount 的部分(<div id=\"root\">)，前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（__INITIAL_STATE__），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。\n\n\n页面内链接跳转处理\nreact-router 提供了一个 <Link> 组件用来替代 <a> 标签，它负责管理浏览器 history，从而不是每次点击链接都去请求服务器，然后可以通过绑定 onClick 事件来作其他处理。\n\n比如在 /list 页面，对于每一个 item 都会用 <Link> 绑定一个 route url：/item/:id，并且绑定 onClick 去触发 dispatch(fetchItem(id)) 获取数据，显示详情页内容。\n","source":"_posts/React.md","raw":"---\ntitle: React\ndate: 2021-01-31 21:09:39\n---\n\n#### 组件生命周期\n\n一个组件类由extends Component 创建，并且提供一个render方法以及其他可选的生命周期函数、组件相关事件定义\n\n<pre>getInitialState</pre>\n初始化 this.state的值，只在组件装载之前调用一次。\nEs6： 构造函数中 (construcor)进行初始化\n\n<pre>getDefaultProps</pre>\n组件创建时调用一次并缓存返回的对象（在初始化之前就调用）\nEs6：直接定义defaultProps这个类属性来替代，\n         Counter.defaultProps = { initialCount: 0 };\n\n<pre>Render</pre>\n组装生成这个组件的HTML结构，也可以返回null或false\n\n\n\n#### 生命周期函数\n\n##### 装载组件触发\n\n<pre>componentWillMount </pre>\n在装载之前调用一次，在render之前调用，可以再这里调用setState改变状态，并且不会导致额外调用一次 render\n\n<pre>componentDidMount</pre>\n在装载完成以后调用一次，在render之后调用，通过ReactDOM.findDOMNode(this)获取组件DOM节点\n\n##### 更新组件触发\n\n这些不会在首次render调用\n<pre>componentWillReceiveProps\nshouldComponentUpdate\ncomponentWillUpdate\ncomponentDidUpdate</pre>\n\n##### 卸载组件触发\n<pre>componentWillUnmount</pre>\n\n#### 事件处理\n\n#####  绑定事件\n<pre>this.handleClick.bind(this)</pre>\n要显式调用bind(this)将事件函数上下文绑定在组件实例上，尽量使用显式容易理解的js代码\n\n##### 合成事件 \n消除了IE与W3C标准之前的兼容问题\n合成事件已时间委托方式绑定在组件最上层 ，并且在组件卸载时候自动销毁绑定事件。\n\n##### 原生事件\n比如在componentDidMount方法里面通过addEventListener绑定的事件就是浏览器原生事件\n\n##### 参数传递\n<pre>this.handleClick.bind>this.handleClick.bind ( this, 'extra param')</pre>\n\n\n##### DOM操作\nReactDOM.render组件返回组件实例（无状态的返回null）\n\n<pre>findDOMNode()\nimport { findDOMNode } from 'react-dom';\n// Inside Component class\ncomponentDidMound() {\n  const el = findDOMNode(this);\n}\n//findDOMNode() 不能用在无状态组件上。</pre>\n\n##### Refs\n通过引用DOM元素上面设置一个ref属性指定一个名称，然后通过this.refs.name来访问对应的Dom元素\n\n如果ref设置在原生HTML元素上，拿到的就是DOM元素，如果设置在自定义组件上，拿到就是组件实例，通过findDOMNode来拿到组件的DOM元素。\n\n##### 小结Ref：\n1.  可以使用ref到的组件定义的任何公共方法，比如 this.refs.myTypehead.reset()\n2.  Refs是访问到组件内部DOM节点唯一可靠的方法\n3.  Refs会自动销毁对子组件的引用（当子组件删除时）\n4.  不要在render或者render之前访问refs\n5.  不要滥用 refs \n\n\n##### This.props.children\n组件标签里面包含的子元素会通过props.children传递进来\n一般可以直接将这个属性作为父组件的子元素render\n<pre>Const Parent=(props)=><div>{props.children}</div></pre>\n\nprops.children通常是一个组件对象的数组，但是当只有一个元素的时候，props.children将是这个唯一的子元素，而不是数组了。\n\n##### 组件间通信\n父子组件间通信\n\n通过props属性传递，在父组件给子组件设置props，然后子组件通过props访问到父组件的数据/方法，搭建了父子组件间通信的桥梁。\n\n##### Flux\n\n**React：MVC中V\nFlux：M和C\nFlux(四部分)           Action -> Dispatcher -> Store -> View**\n\n\n1.  The dispatcher 处理动作分发，维护store之间的依赖关系\n2.  The stores 数据和逻辑部分\n3.  The views React组件，这一层可以看做controller-views,作为视图同时响应用户交互\n4.  The actions 提供给dispatcher传递数据给store\n\n##### 单项数据流\n\n\n流程如下：\n首先要有 action，通过定义一些 action creator 方法根据需要创建 Action 提供给 dispatcher\nView 层通过用户交互（比如 onClick）会触发 Action\nDispatcher 会分发触发的 Action 给所有注册的 Store 的回调函数\nStore 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了\nView 会监听这个 change 事件，拿到对应的新数据并调用 setState 更新组件 UI\n所有的状态都由 Store 来维护，通过 Action 传递数据，构成了如上所述的单向数据流循环。\n\n\n# Redux\n\n## 三个基本原则\n1.  整个应用只有唯一一个可信数据源，也就是只有一个 Store\n2.  State 只能通过触发 Action 来更改\n3.  State 的更改必须写成纯函数，也就是每次更改总是返回一个新的 State，在 Redux 里这种函数称为 Reducer\n\n### Actions\n\nactions包含{type,payload}的对象，type是一个常量用来标识动作类型，payload是这个动作携带的数据。Action需要通过store.dispatch()方法来发送。\n\n一般来说，会使用函数（Action Creators）来生成 action，这样会有更大的灵活性，Action Creators 是一个 pure function，它最后会返回一个 action 对象：\n\nfunction addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n所以现在要触发一个动作只要调用 dispatch: dispatch(addTodo(text))\n\n### Reducers \n\nReducers用来处理Action触发的对状态树的更改。\n\n一个reducers函数会接受oldState和action两个参数，返回一个新的state:(oldState,action)=>newState。\n\nRedux提供一个工具函数combineReducers简化reducer合并\n\nimport { combineReducers } from 'redux';\n\nconst someApp = combineReducers({\n  a: reducerA,\n  b: reducerB\n});\n如果reducer函数名字和字段名字相同，利用es6的destructuring可以简化成 combineReducers({a,b})\n\n### Store\nStore负责连接Action和Reducer。\n作用：\n\t1. Hold 住整个应用的 State 状态树\n\t2. 提供一个 getState() 方法获取 State\n\t3. 提供一个 dispatch() 方法发送 action 更改 State\n\t4. 提供一个 subscribe() 方法注册回调函数监听 State 的更改\n\n创建一个 Store 很容易，将 root reducer 函数传递给 createStore 方法即可：\n\nimport { createStore } from 'redux';\nimport someApp from './reducers';\nlet store = createStore(someApp);\n\n// 你也可以额外指定一个初始 State（initialState），这对于服务端渲染很有用\n// let store = createStore(someApp, window.STATE_FROM_SERVER);\n\n\n拿到了store.dispatch,用来分发action\nstore.dispatch({ type: 'CHANGE_A' });\nstore.dispatch({ type: 'CHANGE_B', payload: 'Modified b' });\n\n### 在 React 应用中使用 Redux\n\n和 Flux 类似，Redux 也是需要注册一个回调函数 store.subscribe(listener) 来获取 State 的更新，然后我们要在 listener 里面调用 setState() 来更新 React 组件。\n\n<Provider>\n<Provider> 作为一个容器组件，用来接受 Store，并且让 Store 对子组件可用，用法如下：\n\nimport { render } from 'react-dom';\nimport { Provider } from 'react-redux';\nimport App from './app';\n\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n这时候 <Provider> 里面的子组件 <App /> 才可以使用 connect 方法关联 store。\n\n### Connect\n\nconnect() 这个方法略微复杂一点，主要是因为它的用法非常灵活：connect([mapStateToProps], mapDispatchToProps], [mergeProps], [options])，它最多接受4个参数，都是可选的，并且这个方法调用会返回另一个函数，这个返回的函数来接受一个组件类作为参数，最后才返回一个和 Redux store 关联起来的新组件，类似这样：\n\nclass App extends Component { ... }\nexport default connect()(App);\n这样就可以在 App 这个组件里面通过 props 拿到 Store 的 dispatch 方法，但是注意现在的 App 没有监听 Store 的状态更改，如果要监听 Store 的状态更改，必须要指定 mapStateToProps 参数。\n\n参数 \n\t• [mapStateToProps(state, [ownProps]): stateProps]: \n\t\n\t第一个可选参数是一个函数，只有指定了这个参数，这个关联（connected）组件才会监听 Redux Store 的更新，每次更新都会调用 mapStateToProps 这个函数，返回一个字面量对象将会合并到组件的 props 属性。 ownProps 是可选的第二个参数，它是传递给组件的 props，当组件获取到新的 props 时，ownProps 都会拿到这个值并且执行 mapStateToProps 这个函数。\n\t\n\t• [mapDispatchProps(dispatch, [ownProps]): dispatchProps]:\n\t\n\t 这个函数用来指定如何传递 dispatch 给组件，在这个函数里面直接 dispatch action creator，返回一个字面量对象将会合并到组件的 props 属性，这样关联组件可以直接通过 props 调用到 action， Redux 提供了一个 bindActionCreators() 辅助函数来简化这种写法。 如果省略这个参数，默认直接把 dispatch 作为 props 传入。ownProps 作用同上。\n\t\n\t\n\t\n表单\n\n表单元素有这么几种属于状态的属性：\n\n\t· value，对应 <input> 和 <textarea> 所有\n\t· checked，对应类型为 checkbox 和 radio 的 <input> 所有\n\t· selected，对应 <option> 所有\n\t\n受控组件\n\t\n用onchange事件改变状态属性\n\n非受控组件\n\n如果你想要给“状态属性”设置默认值，就要用 React 提供的特殊属性 defaultValue，对于 checked 会有 defaultChecked，<option> 也是使用 defaultValue。\n\n\n<select>\n\n在 HTML 中 <select> 标签指定选中项都是通过对应 <option> 的 selected 属性来做的，但是在 React 修改成统一使用 value。\n\n\n### 总结\n\n#### 关于 Store：\n\n1. 整个应用只有一个唯一的 Store\n2.  Store 对应的状态树（State），由调用一个 reducer 函数（root reducer）生成\n3.  状态树上的每个字段都可以进一步由不同的 reducer 函数生成\n4.  Store 包含了几个方法比如 dispatch, getState 来处理数据流\n5.  Store 的状态树只能由 dispatch(action) 来触发更改\n\n#### Redux 的数据流：\n\n1. action 是一个包含 { type, payload } 的对象\n2.  reducer 函数通过 store.dispatch(action) 触发\n3.  reducer 函数接受 (state, action) 两个参数，返回一个新的 state\n4. reducer 函数判断 action.type 然后处理对应的 action.payload 数据来更新状态树\n5.  所以对于整个应用来说，一个 Store 就对应一个 UI 快照，服务器端渲染就简化成了在服务器端初始化 Store，将 Store 传入应用的根组件，针对根组件调用 renderToString 就将整个应用输出成包含了初始化数据的 HTML。 \n\n#### React-router\n\nreact-router 通过一种声明式的方式匹配不同路由决定在页面上展示不同的组件，并且通过 props 将路由信息传递给组件使用，所以只要路由变更，props 就会变化，触发组件 re-render。\n\n\n#### Reducer\n\nStore 是由 reducer 产生的，所以 reducer 实际上反映了 Store 的状态树结构。\n\n./reducers/index.js\n\n<pre>import listReducer from './list';\nimport itemReducer from './item';\n\nexport default function rootReducer(state = {}, action) {\n  return {\n    list: listReducer(state.list, action),\n    item: itemReducer(state.item, action)\n  };\n  }</pre>\nrootReducer 的 state 参数就是整个 Store 的状态树，状态树下的每个字段对应也可以有自己的 reducer，所以这里引入了 listReducer 和 itemReducer，可以看到这两个 reducer 的 state 参数就只是整个状态树上对应的 list 和 item 字段。\n\n具体到 ./reducers/list.js\n\n<pre>const initialState = [];\n\nexport default function listReducer(state = initialState, action) {\n  switch(action.type) {\n  case 'FETCH_LIST_SUCCESS': return [...action.payload];\n  default: return state;\n  }\n  }</pre>\nlist 就是一个包含 items 的简单数组，可能类似这种结构：[{ id: 0, name: 'first item'}, {id: 1, name: 'second item'}]，从 'FETCH_LIST_SUCCESS' 的 action.payload 获得。\n\n然后是 ./reducers/item.js，处理获取到的 item 数据\n\n<pre>const initialState = {};\n\nexport default function listReducer(state = initialState, action) {\n  switch(action.type) {\n  case 'FETCH_ITEM_SUCCESS': return [...action.payload];\n  default: return state;\n  }\n  }</pre>\n\n\n#### Action\n对应的应该要有两个 action 来获取 list 和 item，触发 reducer 更改 Store，这里我们定义 fetchList 和 fetchItem 两个 action。\n\n./actions/index.js\n\n<pre>import fetch from 'isomorphic-fetch';\n\nexport function fetchList() {\n  return (dispatch) => {\n    return fetch('/api/list')\n        .then(res => res.json())\n        .then(json => dispatch({ type: 'FETCH_LIST_SUCCESS', payload: json }));\n  }\n}\n\nexport function fetchItem(id) {\n  return (dispatch) => {\n    if (!id) return Promise.resolve();\n    return fetch(`/api/item/${id}`)\n        .then(res => res.json())\n        .then(json => dispatch({ type: 'FETCH_ITEM_SUCCESS', payload: json }));\n  }\n  }</pre>\nisomorphic-fetch 是一个前后端通用的 Ajax 实现，前后端要共享代码这点很重要。\n\n另外因为涉及到异步请求，这里的 action 用到了 thunk，也就是函数，redux 通过 thunk-middleware 来处理这类 action，把函数当作普通的 action dispatch 就好了，比如 dispatch(fetchList())\n\n\n#### Store\n我们用一个独立的 ./store.js，配置（比如 Apply Middleware）生成 Store\n\n<pre>import { createStore } from 'redux';\nimport rootReducer from './reducers';\n\n// Apply middleware here\n// ...\n\nexport default function configureStore(initialState) {\n  const store = createStore(rootReducer, initialState);\n  return store;\n  }</pre>\n\n\n\n#### react-redux\n实现 List ，Item 组件，然后把 Redux 和 React 组件关联起来\n./app.js\n\n<pre>\nimport React from 'react';\nimport { render } from 'react-dom';\nimport { Router } from 'react-router';\nimport createBrowserHistory from 'history/lib/createBrowserHistory';\nimport { Provider } from 'react-redux';\nimport routes from './routes';\nimport configureStore from './store';\n\n// __INITIAL_STATE__来自服务器端渲染\n</pre>\n<code>\nconst initialState = window.__INITIAL_STATE__;\nconst store = configureStore(initialState);\nconst Root = (props) => {\n  return (\n <pre>     <Provider store={store}></pre>\n   <pre>     <Router history={createBrowserHistory()}></pre>\n   <pre>       {routes}</pre>\n   <pre>     </Router></pre>\n   <pre>   </Provider></pre>\n  );\n}\n\nrender(<Root />, document.getElementById('root'));</code>\n\n##### 到此 客户端部分结束\n\n\n#### Server Rendering\n获取数据调用action,routes在服务端处理参考 react-router server rendering ，在服务器端用一个match方法将拿到的request url 匹配到我们之前定义的routes，解析成和客户端一致的props对象传递给组件。\n\n服务器端渲染部分可以直接通过共用客户端 store.dispatch(action) 来统一获取 Store 数据。另外注意 renderFullPage 生成的页面 HTML 在 React 组件 mount 的部分(<div id=\"root\">)，前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（__INITIAL_STATE__），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。\n\n\n页面内链接跳转处理\nreact-router 提供了一个 <Link> 组件用来替代 <a> 标签，它负责管理浏览器 history，从而不是每次点击链接都去请求服务器，然后可以通过绑定 onClick 事件来作其他处理。\n\n比如在 /list 页面，对于每一个 item 都会用 <Link> 绑定一个 route url：/item/:id，并且绑定 onClick 去触发 dispatch(fetchItem(id)) 获取数据，显示详情页内容。\n","slug":"React","published":1,"updated":"2021-01-31T12:56:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl39veq540000dozshstu8xwd","content":"<h4 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h4><p>一个组件类由extends Component 创建，并且提供一个render方法以及其他可选的生命周期函数、组件相关事件定义</p>\n<pre>getInitialState</pre>\n<p>初始化 this.state的值，只在组件装载之前调用一次。<br>Es6： 构造函数中 (construcor)进行初始化</p>\n<pre>getDefaultProps</pre>\n<p>组件创建时调用一次并缓存返回的对象（在初始化之前就调用）<br>Es6：直接定义defaultProps这个类属性来替代，<br>         Counter.defaultProps = { initialCount: 0 };</p>\n<pre>Render</pre>\n<p>组装生成这个组件的HTML结构，也可以返回null或false</p>\n<h4 id=\"生命周期函数\"><a href=\"#生命周期函数\" class=\"headerlink\" title=\"生命周期函数\"></a>生命周期函数</h4><h5 id=\"装载组件触发\"><a href=\"#装载组件触发\" class=\"headerlink\" title=\"装载组件触发\"></a>装载组件触发</h5><pre>componentWillMount </pre>\n<p>在装载之前调用一次，在render之前调用，可以再这里调用setState改变状态，并且不会导致额外调用一次 render</p>\n<pre>componentDidMount</pre>\n<p>在装载完成以后调用一次，在render之后调用，通过ReactDOM.findDOMNode(this)获取组件DOM节点</p>\n<h5 id=\"更新组件触发\"><a href=\"#更新组件触发\" class=\"headerlink\" title=\"更新组件触发\"></a>更新组件触发</h5><p>这些不会在首次render调用</p>\n<pre>componentWillReceiveProps\nshouldComponentUpdate\ncomponentWillUpdate\ncomponentDidUpdate</pre>\n\n<h5 id=\"卸载组件触发\"><a href=\"#卸载组件触发\" class=\"headerlink\" title=\"卸载组件触发\"></a>卸载组件触发</h5><pre>componentWillUnmount</pre>\n\n<h4 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h4><h5 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h5><pre>this.handleClick.bind(this)</pre>\n<p>要显式调用bind(this)将事件函数上下文绑定在组件实例上，尽量使用显式容易理解的js代码</p>\n<h5 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h5><p>消除了IE与W3C标准之前的兼容问题<br>合成事件已时间委托方式绑定在组件最上层 ，并且在组件卸载时候自动销毁绑定事件。</p>\n<h5 id=\"原生事件\"><a href=\"#原生事件\" class=\"headerlink\" title=\"原生事件\"></a>原生事件</h5><p>比如在componentDidMount方法里面通过addEventListener绑定的事件就是浏览器原生事件</p>\n<h5 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h5><pre>this.handleClick.bind>this.handleClick.bind ( this, 'extra param')</pre>\n\n\n<h5 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h5><p>ReactDOM.render组件返回组件实例（无状态的返回null）</p>\n<pre>findDOMNode()\nimport { findDOMNode } from 'react-dom';\n// Inside Component class\ncomponentDidMound() {\n  const el = findDOMNode(this);\n}\n//findDOMNode() 不能用在无状态组件上。</pre>\n\n<h5 id=\"Refs\"><a href=\"#Refs\" class=\"headerlink\" title=\"Refs\"></a>Refs</h5><p>通过引用DOM元素上面设置一个ref属性指定一个名称，然后通过this.refs.name来访问对应的Dom元素</p>\n<p>如果ref设置在原生HTML元素上，拿到的就是DOM元素，如果设置在自定义组件上，拿到就是组件实例，通过findDOMNode来拿到组件的DOM元素。</p>\n<h5 id=\"小结Ref：\"><a href=\"#小结Ref：\" class=\"headerlink\" title=\"小结Ref：\"></a>小结Ref：</h5><ol>\n<li> 可以使用ref到的组件定义的任何公共方法，比如 this.refs.myTypehead.reset()</li>\n<li> Refs是访问到组件内部DOM节点唯一可靠的方法</li>\n<li> Refs会自动销毁对子组件的引用（当子组件删除时）</li>\n<li> 不要在render或者render之前访问refs</li>\n<li> 不要滥用 refs </li>\n</ol>\n<h5 id=\"This-props-children\"><a href=\"#This-props-children\" class=\"headerlink\" title=\"This.props.children\"></a>This.props.children</h5><p>组件标签里面包含的子元素会通过props.children传递进来<br>一般可以直接将这个属性作为父组件的子元素render</p>\n<pre>Const Parent=(props)=><div>{props.children}</div></pre>\n\n<p>props.children通常是一个组件对象的数组，但是当只有一个元素的时候，props.children将是这个唯一的子元素，而不是数组了。</p>\n<h5 id=\"组件间通信\"><a href=\"#组件间通信\" class=\"headerlink\" title=\"组件间通信\"></a>组件间通信</h5><p>父子组件间通信</p>\n<p>通过props属性传递，在父组件给子组件设置props，然后子组件通过props访问到父组件的数据/方法，搭建了父子组件间通信的桥梁。</p>\n<h5 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h5><p><strong>React：MVC中V<br>Flux：M和C<br>Flux(四部分)           Action -&gt; Dispatcher -&gt; Store -&gt; View</strong></p>\n<ol>\n<li> The dispatcher 处理动作分发，维护store之间的依赖关系</li>\n<li> The stores 数据和逻辑部分</li>\n<li> The views React组件，这一层可以看做controller-views,作为视图同时响应用户交互</li>\n<li> The actions 提供给dispatcher传递数据给store</li>\n</ol>\n<h5 id=\"单项数据流\"><a href=\"#单项数据流\" class=\"headerlink\" title=\"单项数据流\"></a>单项数据流</h5><p>流程如下：<br>首先要有 action，通过定义一些 action creator 方法根据需要创建 Action 提供给 dispatcher<br>View 层通过用户交互（比如 onClick）会触发 Action<br>Dispatcher 会分发触发的 Action 给所有注册的 Store 的回调函数<br>Store 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了<br>View 会监听这个 change 事件，拿到对应的新数据并调用 setState 更新组件 UI<br>所有的状态都由 Store 来维护，通过 Action 传递数据，构成了如上所述的单向数据流循环。</p>\n<h1 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h1><h2 id=\"三个基本原则\"><a href=\"#三个基本原则\" class=\"headerlink\" title=\"三个基本原则\"></a>三个基本原则</h2><ol>\n<li> 整个应用只有唯一一个可信数据源，也就是只有一个 Store</li>\n<li> State 只能通过触发 Action 来更改</li>\n<li> State 的更改必须写成纯函数，也就是每次更改总是返回一个新的 State，在 Redux 里这种函数称为 Reducer</li>\n</ol>\n<h3 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h3><p>actions包含{type,payload}的对象，type是一个常量用来标识动作类型，payload是这个动作携带的数据。Action需要通过store.dispatch()方法来发送。</p>\n<p>一般来说，会使用函数（Action Creators）来生成 action，这样会有更大的灵活性，Action Creators 是一个 pure function，它最后会返回一个 action 对象：</p>\n<p>function addTodo(text) {<br>  return {<br>    type: ‘ADD_TODO’,<br>    text<br>  }<br>}<br>所以现在要触发一个动作只要调用 dispatch: dispatch(addTodo(text))</p>\n<h3 id=\"Reducers\"><a href=\"#Reducers\" class=\"headerlink\" title=\"Reducers\"></a>Reducers</h3><p>Reducers用来处理Action触发的对状态树的更改。</p>\n<p>一个reducers函数会接受oldState和action两个参数，返回一个新的state:(oldState,action)=&gt;newState。</p>\n<p>Redux提供一个工具函数combineReducers简化reducer合并</p>\n<p>import { combineReducers } from ‘redux’;</p>\n<p>const someApp = combineReducers({<br>  a: reducerA,<br>  b: reducerB<br>});<br>如果reducer函数名字和字段名字相同，利用es6的destructuring可以简化成 combineReducers({a,b})</p>\n<h3 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h3><p>Store负责连接Action和Reducer。<br>作用：<br>    1. Hold 住整个应用的 State 状态树<br>    2. 提供一个 getState() 方法获取 State<br>    3. 提供一个 dispatch() 方法发送 action 更改 State<br>    4. 提供一个 subscribe() 方法注册回调函数监听 State 的更改</p>\n<p>创建一个 Store 很容易，将 root reducer 函数传递给 createStore 方法即可：</p>\n<p>import { createStore } from ‘redux’;<br>import someApp from ‘./reducers’;<br>let store = createStore(someApp);</p>\n<p>// 你也可以额外指定一个初始 State（initialState），这对于服务端渲染很有用<br>// let store = createStore(someApp, window.STATE_FROM_SERVER);</p>\n<p>拿到了store.dispatch,用来分发action<br>store.dispatch({ type: ‘CHANGE_A’ });<br>store.dispatch({ type: ‘CHANGE_B’, payload: ‘Modified b’ });</p>\n<h3 id=\"在-React-应用中使用-Redux\"><a href=\"#在-React-应用中使用-Redux\" class=\"headerlink\" title=\"在 React 应用中使用 Redux\"></a>在 React 应用中使用 Redux</h3><p>和 Flux 类似，Redux 也是需要注册一个回调函数 store.subscribe(listener) 来获取 State 的更新，然后我们要在 listener 里面调用 setState() 来更新 React 组件。</p>\n<Provider>\n<Provider> 作为一个容器组件，用来接受 Store，并且让 Store 对子组件可用，用法如下：\n\n<p>import { render } from ‘react-dom’;<br>import { Provider } from ‘react-redux’;<br>import App from ‘./app’;</p>\n<p>render(<br>  <Provider store={store}><br>    <App /><br>  </Provider>,<br>  document.getElementById(‘root’)<br>);<br>这时候 <Provider> 里面的子组件 <App /> 才可以使用 connect 方法关联 store。</p>\n<h3 id=\"Connect\"><a href=\"#Connect\" class=\"headerlink\" title=\"Connect\"></a>Connect</h3><p>connect() 这个方法略微复杂一点，主要是因为它的用法非常灵活：connect([mapStateToProps], mapDispatchToProps], [mergeProps], [options])，它最多接受4个参数，都是可选的，并且这个方法调用会返回另一个函数，这个返回的函数来接受一个组件类作为参数，最后才返回一个和 Redux store 关联起来的新组件，类似这样：</p>\n<p>class App extends Component { … }<br>export default connect()(App);<br>这样就可以在 App 这个组件里面通过 props 拿到 Store 的 dispatch 方法，但是注意现在的 App 没有监听 Store 的状态更改，如果要监听 Store 的状态更改，必须要指定 mapStateToProps 参数。</p>\n<p>参数<br>    • [mapStateToProps(state, [ownProps]): stateProps]: </p>\n<pre><code>第一个可选参数是一个函数，只有指定了这个参数，这个关联（connected）组件才会监听 Redux Store 的更新，每次更新都会调用 mapStateToProps 这个函数，返回一个字面量对象将会合并到组件的 props 属性。 ownProps 是可选的第二个参数，它是传递给组件的 props，当组件获取到新的 props 时，ownProps 都会拿到这个值并且执行 mapStateToProps 这个函数。\n\n• [mapDispatchProps(dispatch, [ownProps]): dispatchProps]:\n\n 这个函数用来指定如何传递 dispatch 给组件，在这个函数里面直接 dispatch action creator，返回一个字面量对象将会合并到组件的 props 属性，这样关联组件可以直接通过 props 调用到 action， Redux 提供了一个 bindActionCreators() 辅助函数来简化这种写法。 如果省略这个参数，默认直接把 dispatch 作为 props 传入。ownProps 作用同上。</code></pre>\n<p>表单</p>\n<p>表单元素有这么几种属于状态的属性：</p>\n<pre><code>· value，对应 &lt;input&gt; 和 &lt;textarea&gt; 所有\n· checked，对应类型为 checkbox 和 radio 的 &lt;input&gt; 所有\n· selected，对应 &lt;option&gt; 所有</code></pre>\n<p>受控组件</p>\n<p>用onchange事件改变状态属性</p>\n<p>非受控组件</p>\n<p>如果你想要给“状态属性”设置默认值，就要用 React 提供的特殊属性 defaultValue，对于 checked 会有 defaultChecked，<option> 也是使用 defaultValue。</p>\n<select>\n\n<p>在 HTML 中 <select> 标签指定选中项都是通过对应 <option> 的 selected 属性来做的，但是在 React 修改成统一使用 value。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"关于-Store：\"><a href=\"#关于-Store：\" class=\"headerlink\" title=\"关于 Store：\"></a>关于 Store：</h4><ol>\n<li>整个应用只有一个唯一的 Store</li>\n<li> Store 对应的状态树（State），由调用一个 reducer 函数（root reducer）生成</li>\n<li> 状态树上的每个字段都可以进一步由不同的 reducer 函数生成</li>\n<li> Store 包含了几个方法比如 dispatch, getState 来处理数据流</li>\n<li> Store 的状态树只能由 dispatch(action) 来触发更改</li>\n</ol>\n<h4 id=\"Redux-的数据流：\"><a href=\"#Redux-的数据流：\" class=\"headerlink\" title=\"Redux 的数据流：\"></a>Redux 的数据流：</h4><ol>\n<li>action 是一个包含 { type, payload } 的对象</li>\n<li> reducer 函数通过 store.dispatch(action) 触发</li>\n<li> reducer 函数接受 (state, action) 两个参数，返回一个新的 state</li>\n<li>reducer 函数判断 action.type 然后处理对应的 action.payload 数据来更新状态树</li>\n<li> 所以对于整个应用来说，一个 Store 就对应一个 UI 快照，服务器端渲染就简化成了在服务器端初始化 Store，将 Store 传入应用的根组件，针对根组件调用 renderToString 就将整个应用输出成包含了初始化数据的 HTML。 </li>\n</ol>\n<h4 id=\"React-router\"><a href=\"#React-router\" class=\"headerlink\" title=\"React-router\"></a>React-router</h4><p>react-router 通过一种声明式的方式匹配不同路由决定在页面上展示不同的组件，并且通过 props 将路由信息传递给组件使用，所以只要路由变更，props 就会变化，触发组件 re-render。</p>\n<h4 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h4><p>Store 是由 reducer 产生的，所以 reducer 实际上反映了 Store 的状态树结构。</p>\n<p>./reducers/index.js</p>\n<pre>import listReducer from './list';\nimport itemReducer from './item';\n\nexport default function rootReducer(state = {}, action) {\n  return {\n    list: listReducer(state.list, action),\n    item: itemReducer(state.item, action)\n  };\n  }</pre>\n<p>rootReducer 的 state 参数就是整个 Store 的状态树，状态树下的每个字段对应也可以有自己的 reducer，所以这里引入了 listReducer 和 itemReducer，可以看到这两个 reducer 的 state 参数就只是整个状态树上对应的 list 和 item 字段。</p>\n<p>具体到 ./reducers/list.js</p>\n<pre>const initialState = [];\n\nexport default function listReducer(state = initialState, action) {\n  switch(action.type) {\n  case 'FETCH_LIST_SUCCESS': return [...action.payload];\n  default: return state;\n  }\n  }</pre>\n<p>list 就是一个包含 items 的简单数组，可能类似这种结构：[{ id: 0, name: ‘first item’}, {id: 1, name: ‘second item’}]，从 ‘FETCH_LIST_SUCCESS’ 的 action.payload 获得。</p>\n<p>然后是 ./reducers/item.js，处理获取到的 item 数据</p>\n<pre>const initialState = {};\n\nexport default function listReducer(state = initialState, action) {\n  switch(action.type) {\n  case 'FETCH_ITEM_SUCCESS': return [...action.payload];\n  default: return state;\n  }\n  }</pre>\n\n\n<h4 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h4><p>对应的应该要有两个 action 来获取 list 和 item，触发 reducer 更改 Store，这里我们定义 fetchList 和 fetchItem 两个 action。</p>\n<p>./actions/index.js</p>\n<pre>import fetch from 'isomorphic-fetch';\n\nexport function fetchList() {\n  return (dispatch) => {\n    return fetch('/api/list')\n        .then(res => res.json())\n        .then(json => dispatch({ type: 'FETCH_LIST_SUCCESS', payload: json }));\n  }\n}\n\nexport function fetchItem(id) {\n  return (dispatch) => {\n    if (!id) return Promise.resolve();\n    return fetch(`/api/item/${id}`)\n        .then(res => res.json())\n        .then(json => dispatch({ type: 'FETCH_ITEM_SUCCESS', payload: json }));\n  }\n  }</pre>\n<p>isomorphic-fetch 是一个前后端通用的 Ajax 实现，前后端要共享代码这点很重要。</p>\n<p>另外因为涉及到异步请求，这里的 action 用到了 thunk，也就是函数，redux 通过 thunk-middleware 来处理这类 action，把函数当作普通的 action dispatch 就好了，比如 dispatch(fetchList())</p>\n<h4 id=\"Store-1\"><a href=\"#Store-1\" class=\"headerlink\" title=\"Store\"></a>Store</h4><p>我们用一个独立的 ./store.js，配置（比如 Apply Middleware）生成 Store</p>\n<pre>import { createStore } from 'redux';\nimport rootReducer from './reducers';\n\n// Apply middleware here\n// ...\n\nexport default function configureStore(initialState) {\n  const store = createStore(rootReducer, initialState);\n  return store;\n  }</pre>\n\n\n\n<h4 id=\"react-redux\"><a href=\"#react-redux\" class=\"headerlink\" title=\"react-redux\"></a>react-redux</h4><p>实现 List ，Item 组件，然后把 Redux 和 React 组件关联起来<br>./app.js</p>\n<pre>\nimport React from 'react';\nimport { render } from 'react-dom';\nimport { Router } from 'react-router';\nimport createBrowserHistory from 'history/lib/createBrowserHistory';\nimport { Provider } from 'react-redux';\nimport routes from './routes';\nimport configureStore from './store';\n\n// __INITIAL_STATE__来自服务器端渲染\n</pre>\n<code>\nconst initialState = window.__INITIAL_STATE__;\nconst store = configureStore(initialState);\nconst Root = (props) => &#123;\n  return (\n <pre>     <Provider store=&#123;store&#125;></pre>\n   <pre>     <Router history=&#123;createBrowserHistory()&#125;></pre>\n   <pre>       &#123;routes&#125;</pre>\n   <pre>     </Router></pre>\n   <pre>   </Provider></pre>\n  );\n&#125;\n\n<p>render(<Root />, document.getElementById(‘root’));</code></p>\n<h5 id=\"到此-客户端部分结束\"><a href=\"#到此-客户端部分结束\" class=\"headerlink\" title=\"到此 客户端部分结束\"></a>到此 客户端部分结束</h5><h4 id=\"Server-Rendering\"><a href=\"#Server-Rendering\" class=\"headerlink\" title=\"Server Rendering\"></a>Server Rendering</h4><p>获取数据调用action,routes在服务端处理参考 react-router server rendering ，在服务器端用一个match方法将拿到的request url 匹配到我们之前定义的routes，解析成和客户端一致的props对象传递给组件。</p>\n<p>服务器端渲染部分可以直接通过共用客户端 store.dispatch(action) 来统一获取 Store 数据。另外注意 renderFullPage 生成的页面 HTML 在 React 组件 mount 的部分(<div id=\"root\">)，前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（__INITIAL_STATE__），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。</p>\n<p>页面内链接跳转处理<br>react-router 提供了一个 <Link> 组件用来替代 <a> 标签，它负责管理浏览器 history，从而不是每次点击链接都去请求服务器，然后可以通过绑定 onClick 事件来作其他处理。</p>\n<p>比如在 /list 页面，对于每一个 item 都会用 <Link> 绑定一个 route url：/item/:id，并且绑定 onClick 去触发 dispatch(fetchItem(id)) 获取数据，显示详情页内容。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h4><p>一个组件类由extends Component 创建，并且提供一个render方法以及其他可选的生命周期函数、组件相关事件定义</p>\n<pre>getInitialState</pre>\n<p>初始化 this.state的值，只在组件装载之前调用一次。<br>Es6： 构造函数中 (construcor)进行初始化</p>\n<pre>getDefaultProps</pre>\n<p>组件创建时调用一次并缓存返回的对象（在初始化之前就调用）<br>Es6：直接定义defaultProps这个类属性来替代，<br>         Counter.defaultProps = { initialCount: 0 };</p>\n<pre>Render</pre>\n<p>组装生成这个组件的HTML结构，也可以返回null或false</p>\n<h4 id=\"生命周期函数\"><a href=\"#生命周期函数\" class=\"headerlink\" title=\"生命周期函数\"></a>生命周期函数</h4><h5 id=\"装载组件触发\"><a href=\"#装载组件触发\" class=\"headerlink\" title=\"装载组件触发\"></a>装载组件触发</h5><pre>componentWillMount </pre>\n<p>在装载之前调用一次，在render之前调用，可以再这里调用setState改变状态，并且不会导致额外调用一次 render</p>\n<pre>componentDidMount</pre>\n<p>在装载完成以后调用一次，在render之后调用，通过ReactDOM.findDOMNode(this)获取组件DOM节点</p>\n<h5 id=\"更新组件触发\"><a href=\"#更新组件触发\" class=\"headerlink\" title=\"更新组件触发\"></a>更新组件触发</h5><p>这些不会在首次render调用</p>\n<pre>componentWillReceiveProps\nshouldComponentUpdate\ncomponentWillUpdate\ncomponentDidUpdate</pre>\n\n<h5 id=\"卸载组件触发\"><a href=\"#卸载组件触发\" class=\"headerlink\" title=\"卸载组件触发\"></a>卸载组件触发</h5><pre>componentWillUnmount</pre>\n\n<h4 id=\"事件处理\"><a href=\"#事件处理\" class=\"headerlink\" title=\"事件处理\"></a>事件处理</h4><h5 id=\"绑定事件\"><a href=\"#绑定事件\" class=\"headerlink\" title=\"绑定事件\"></a>绑定事件</h5><pre>this.handleClick.bind(this)</pre>\n<p>要显式调用bind(this)将事件函数上下文绑定在组件实例上，尽量使用显式容易理解的js代码</p>\n<h5 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h5><p>消除了IE与W3C标准之前的兼容问题<br>合成事件已时间委托方式绑定在组件最上层 ，并且在组件卸载时候自动销毁绑定事件。</p>\n<h5 id=\"原生事件\"><a href=\"#原生事件\" class=\"headerlink\" title=\"原生事件\"></a>原生事件</h5><p>比如在componentDidMount方法里面通过addEventListener绑定的事件就是浏览器原生事件</p>\n<h5 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h5><pre>this.handleClick.bind>this.handleClick.bind ( this, 'extra param')</pre>\n\n\n<h5 id=\"DOM操作\"><a href=\"#DOM操作\" class=\"headerlink\" title=\"DOM操作\"></a>DOM操作</h5><p>ReactDOM.render组件返回组件实例（无状态的返回null）</p>\n<pre>findDOMNode()\nimport { findDOMNode } from 'react-dom';\n// Inside Component class\ncomponentDidMound() {\n  const el = findDOMNode(this);\n}\n//findDOMNode() 不能用在无状态组件上。</pre>\n\n<h5 id=\"Refs\"><a href=\"#Refs\" class=\"headerlink\" title=\"Refs\"></a>Refs</h5><p>通过引用DOM元素上面设置一个ref属性指定一个名称，然后通过this.refs.name来访问对应的Dom元素</p>\n<p>如果ref设置在原生HTML元素上，拿到的就是DOM元素，如果设置在自定义组件上，拿到就是组件实例，通过findDOMNode来拿到组件的DOM元素。</p>\n<h5 id=\"小结Ref：\"><a href=\"#小结Ref：\" class=\"headerlink\" title=\"小结Ref：\"></a>小结Ref：</h5><ol>\n<li> 可以使用ref到的组件定义的任何公共方法，比如 this.refs.myTypehead.reset()</li>\n<li> Refs是访问到组件内部DOM节点唯一可靠的方法</li>\n<li> Refs会自动销毁对子组件的引用（当子组件删除时）</li>\n<li> 不要在render或者render之前访问refs</li>\n<li> 不要滥用 refs </li>\n</ol>\n<h5 id=\"This-props-children\"><a href=\"#This-props-children\" class=\"headerlink\" title=\"This.props.children\"></a>This.props.children</h5><p>组件标签里面包含的子元素会通过props.children传递进来<br>一般可以直接将这个属性作为父组件的子元素render</p>\n<pre>Const Parent=(props)=><div>{props.children}</div></pre>\n\n<p>props.children通常是一个组件对象的数组，但是当只有一个元素的时候，props.children将是这个唯一的子元素，而不是数组了。</p>\n<h5 id=\"组件间通信\"><a href=\"#组件间通信\" class=\"headerlink\" title=\"组件间通信\"></a>组件间通信</h5><p>父子组件间通信</p>\n<p>通过props属性传递，在父组件给子组件设置props，然后子组件通过props访问到父组件的数据/方法，搭建了父子组件间通信的桥梁。</p>\n<h5 id=\"Flux\"><a href=\"#Flux\" class=\"headerlink\" title=\"Flux\"></a>Flux</h5><p><strong>React：MVC中V<br>Flux：M和C<br>Flux(四部分)           Action -&gt; Dispatcher -&gt; Store -&gt; View</strong></p>\n<ol>\n<li> The dispatcher 处理动作分发，维护store之间的依赖关系</li>\n<li> The stores 数据和逻辑部分</li>\n<li> The views React组件，这一层可以看做controller-views,作为视图同时响应用户交互</li>\n<li> The actions 提供给dispatcher传递数据给store</li>\n</ol>\n<h5 id=\"单项数据流\"><a href=\"#单项数据流\" class=\"headerlink\" title=\"单项数据流\"></a>单项数据流</h5><p>流程如下：<br>首先要有 action，通过定义一些 action creator 方法根据需要创建 Action 提供给 dispatcher<br>View 层通过用户交互（比如 onClick）会触发 Action<br>Dispatcher 会分发触发的 Action 给所有注册的 Store 的回调函数<br>Store 回调函数根据接收的 Action 更新自身数据之后会触发一个 change 事件通知 View 数据更改了<br>View 会监听这个 change 事件，拿到对应的新数据并调用 setState 更新组件 UI<br>所有的状态都由 Store 来维护，通过 Action 传递数据，构成了如上所述的单向数据流循环。</p>\n<h1 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h1><h2 id=\"三个基本原则\"><a href=\"#三个基本原则\" class=\"headerlink\" title=\"三个基本原则\"></a>三个基本原则</h2><ol>\n<li> 整个应用只有唯一一个可信数据源，也就是只有一个 Store</li>\n<li> State 只能通过触发 Action 来更改</li>\n<li> State 的更改必须写成纯函数，也就是每次更改总是返回一个新的 State，在 Redux 里这种函数称为 Reducer</li>\n</ol>\n<h3 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h3><p>actions包含{type,payload}的对象，type是一个常量用来标识动作类型，payload是这个动作携带的数据。Action需要通过store.dispatch()方法来发送。</p>\n<p>一般来说，会使用函数（Action Creators）来生成 action，这样会有更大的灵活性，Action Creators 是一个 pure function，它最后会返回一个 action 对象：</p>\n<p>function addTodo(text) {<br>  return {<br>    type: ‘ADD_TODO’,<br>    text<br>  }<br>}<br>所以现在要触发一个动作只要调用 dispatch: dispatch(addTodo(text))</p>\n<h3 id=\"Reducers\"><a href=\"#Reducers\" class=\"headerlink\" title=\"Reducers\"></a>Reducers</h3><p>Reducers用来处理Action触发的对状态树的更改。</p>\n<p>一个reducers函数会接受oldState和action两个参数，返回一个新的state:(oldState,action)=&gt;newState。</p>\n<p>Redux提供一个工具函数combineReducers简化reducer合并</p>\n<p>import { combineReducers } from ‘redux’;</p>\n<p>const someApp = combineReducers({<br>  a: reducerA,<br>  b: reducerB<br>});<br>如果reducer函数名字和字段名字相同，利用es6的destructuring可以简化成 combineReducers({a,b})</p>\n<h3 id=\"Store\"><a href=\"#Store\" class=\"headerlink\" title=\"Store\"></a>Store</h3><p>Store负责连接Action和Reducer。<br>作用：<br>    1. Hold 住整个应用的 State 状态树<br>    2. 提供一个 getState() 方法获取 State<br>    3. 提供一个 dispatch() 方法发送 action 更改 State<br>    4. 提供一个 subscribe() 方法注册回调函数监听 State 的更改</p>\n<p>创建一个 Store 很容易，将 root reducer 函数传递给 createStore 方法即可：</p>\n<p>import { createStore } from ‘redux’;<br>import someApp from ‘./reducers’;<br>let store = createStore(someApp);</p>\n<p>// 你也可以额外指定一个初始 State（initialState），这对于服务端渲染很有用<br>// let store = createStore(someApp, window.STATE_FROM_SERVER);</p>\n<p>拿到了store.dispatch,用来分发action<br>store.dispatch({ type: ‘CHANGE_A’ });<br>store.dispatch({ type: ‘CHANGE_B’, payload: ‘Modified b’ });</p>\n<h3 id=\"在-React-应用中使用-Redux\"><a href=\"#在-React-应用中使用-Redux\" class=\"headerlink\" title=\"在 React 应用中使用 Redux\"></a>在 React 应用中使用 Redux</h3><p>和 Flux 类似，Redux 也是需要注册一个回调函数 store.subscribe(listener) 来获取 State 的更新，然后我们要在 listener 里面调用 setState() 来更新 React 组件。</p>\n<Provider>\n<Provider> 作为一个容器组件，用来接受 Store，并且让 Store 对子组件可用，用法如下：\n\n<p>import { render } from ‘react-dom’;<br>import { Provider } from ‘react-redux’;<br>import App from ‘./app’;</p>\n<p>render(<br>  <Provider store={store}><br>    <App /><br>  </Provider>,<br>  document.getElementById(‘root’)<br>);<br>这时候 <Provider> 里面的子组件 <App /> 才可以使用 connect 方法关联 store。</p>\n<h3 id=\"Connect\"><a href=\"#Connect\" class=\"headerlink\" title=\"Connect\"></a>Connect</h3><p>connect() 这个方法略微复杂一点，主要是因为它的用法非常灵活：connect([mapStateToProps], mapDispatchToProps], [mergeProps], [options])，它最多接受4个参数，都是可选的，并且这个方法调用会返回另一个函数，这个返回的函数来接受一个组件类作为参数，最后才返回一个和 Redux store 关联起来的新组件，类似这样：</p>\n<p>class App extends Component { … }<br>export default connect()(App);<br>这样就可以在 App 这个组件里面通过 props 拿到 Store 的 dispatch 方法，但是注意现在的 App 没有监听 Store 的状态更改，如果要监听 Store 的状态更改，必须要指定 mapStateToProps 参数。</p>\n<p>参数<br>    • [mapStateToProps(state, [ownProps]): stateProps]: </p>\n<pre><code>第一个可选参数是一个函数，只有指定了这个参数，这个关联（connected）组件才会监听 Redux Store 的更新，每次更新都会调用 mapStateToProps 这个函数，返回一个字面量对象将会合并到组件的 props 属性。 ownProps 是可选的第二个参数，它是传递给组件的 props，当组件获取到新的 props 时，ownProps 都会拿到这个值并且执行 mapStateToProps 这个函数。\n\n• [mapDispatchProps(dispatch, [ownProps]): dispatchProps]:\n\n 这个函数用来指定如何传递 dispatch 给组件，在这个函数里面直接 dispatch action creator，返回一个字面量对象将会合并到组件的 props 属性，这样关联组件可以直接通过 props 调用到 action， Redux 提供了一个 bindActionCreators() 辅助函数来简化这种写法。 如果省略这个参数，默认直接把 dispatch 作为 props 传入。ownProps 作用同上。</code></pre>\n<p>表单</p>\n<p>表单元素有这么几种属于状态的属性：</p>\n<pre><code>· value，对应 &lt;input&gt; 和 &lt;textarea&gt; 所有\n· checked，对应类型为 checkbox 和 radio 的 &lt;input&gt; 所有\n· selected，对应 &lt;option&gt; 所有</code></pre>\n<p>受控组件</p>\n<p>用onchange事件改变状态属性</p>\n<p>非受控组件</p>\n<p>如果你想要给“状态属性”设置默认值，就要用 React 提供的特殊属性 defaultValue，对于 checked 会有 defaultChecked，<option> 也是使用 defaultValue。</p>\n<select>\n\n<p>在 HTML 中 <select> 标签指定选中项都是通过对应 <option> 的 selected 属性来做的，但是在 React 修改成统一使用 value。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><h4 id=\"关于-Store：\"><a href=\"#关于-Store：\" class=\"headerlink\" title=\"关于 Store：\"></a>关于 Store：</h4><ol>\n<li>整个应用只有一个唯一的 Store</li>\n<li> Store 对应的状态树（State），由调用一个 reducer 函数（root reducer）生成</li>\n<li> 状态树上的每个字段都可以进一步由不同的 reducer 函数生成</li>\n<li> Store 包含了几个方法比如 dispatch, getState 来处理数据流</li>\n<li> Store 的状态树只能由 dispatch(action) 来触发更改</li>\n</ol>\n<h4 id=\"Redux-的数据流：\"><a href=\"#Redux-的数据流：\" class=\"headerlink\" title=\"Redux 的数据流：\"></a>Redux 的数据流：</h4><ol>\n<li>action 是一个包含 { type, payload } 的对象</li>\n<li> reducer 函数通过 store.dispatch(action) 触发</li>\n<li> reducer 函数接受 (state, action) 两个参数，返回一个新的 state</li>\n<li>reducer 函数判断 action.type 然后处理对应的 action.payload 数据来更新状态树</li>\n<li> 所以对于整个应用来说，一个 Store 就对应一个 UI 快照，服务器端渲染就简化成了在服务器端初始化 Store，将 Store 传入应用的根组件，针对根组件调用 renderToString 就将整个应用输出成包含了初始化数据的 HTML。 </li>\n</ol>\n<h4 id=\"React-router\"><a href=\"#React-router\" class=\"headerlink\" title=\"React-router\"></a>React-router</h4><p>react-router 通过一种声明式的方式匹配不同路由决定在页面上展示不同的组件，并且通过 props 将路由信息传递给组件使用，所以只要路由变更，props 就会变化，触发组件 re-render。</p>\n<h4 id=\"Reducer\"><a href=\"#Reducer\" class=\"headerlink\" title=\"Reducer\"></a>Reducer</h4><p>Store 是由 reducer 产生的，所以 reducer 实际上反映了 Store 的状态树结构。</p>\n<p>./reducers/index.js</p>\n<pre>import listReducer from './list';\nimport itemReducer from './item';\n\nexport default function rootReducer(state = {}, action) {\n  return {\n    list: listReducer(state.list, action),\n    item: itemReducer(state.item, action)\n  };\n  }</pre>\n<p>rootReducer 的 state 参数就是整个 Store 的状态树，状态树下的每个字段对应也可以有自己的 reducer，所以这里引入了 listReducer 和 itemReducer，可以看到这两个 reducer 的 state 参数就只是整个状态树上对应的 list 和 item 字段。</p>\n<p>具体到 ./reducers/list.js</p>\n<pre>const initialState = [];\n\nexport default function listReducer(state = initialState, action) {\n  switch(action.type) {\n  case 'FETCH_LIST_SUCCESS': return [...action.payload];\n  default: return state;\n  }\n  }</pre>\n<p>list 就是一个包含 items 的简单数组，可能类似这种结构：[{ id: 0, name: ‘first item’}, {id: 1, name: ‘second item’}]，从 ‘FETCH_LIST_SUCCESS’ 的 action.payload 获得。</p>\n<p>然后是 ./reducers/item.js，处理获取到的 item 数据</p>\n<pre>const initialState = {};\n\nexport default function listReducer(state = initialState, action) {\n  switch(action.type) {\n  case 'FETCH_ITEM_SUCCESS': return [...action.payload];\n  default: return state;\n  }\n  }</pre>\n\n\n<h4 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h4><p>对应的应该要有两个 action 来获取 list 和 item，触发 reducer 更改 Store，这里我们定义 fetchList 和 fetchItem 两个 action。</p>\n<p>./actions/index.js</p>\n<pre>import fetch from 'isomorphic-fetch';\n\nexport function fetchList() {\n  return (dispatch) => {\n    return fetch('/api/list')\n        .then(res => res.json())\n        .then(json => dispatch({ type: 'FETCH_LIST_SUCCESS', payload: json }));\n  }\n}\n\nexport function fetchItem(id) {\n  return (dispatch) => {\n    if (!id) return Promise.resolve();\n    return fetch(`/api/item/${id}`)\n        .then(res => res.json())\n        .then(json => dispatch({ type: 'FETCH_ITEM_SUCCESS', payload: json }));\n  }\n  }</pre>\n<p>isomorphic-fetch 是一个前后端通用的 Ajax 实现，前后端要共享代码这点很重要。</p>\n<p>另外因为涉及到异步请求，这里的 action 用到了 thunk，也就是函数，redux 通过 thunk-middleware 来处理这类 action，把函数当作普通的 action dispatch 就好了，比如 dispatch(fetchList())</p>\n<h4 id=\"Store-1\"><a href=\"#Store-1\" class=\"headerlink\" title=\"Store\"></a>Store</h4><p>我们用一个独立的 ./store.js，配置（比如 Apply Middleware）生成 Store</p>\n<pre>import { createStore } from 'redux';\nimport rootReducer from './reducers';\n\n// Apply middleware here\n// ...\n\nexport default function configureStore(initialState) {\n  const store = createStore(rootReducer, initialState);\n  return store;\n  }</pre>\n\n\n\n<h4 id=\"react-redux\"><a href=\"#react-redux\" class=\"headerlink\" title=\"react-redux\"></a>react-redux</h4><p>实现 List ，Item 组件，然后把 Redux 和 React 组件关联起来<br>./app.js</p>\n<pre>\nimport React from 'react';\nimport { render } from 'react-dom';\nimport { Router } from 'react-router';\nimport createBrowserHistory from 'history/lib/createBrowserHistory';\nimport { Provider } from 'react-redux';\nimport routes from './routes';\nimport configureStore from './store';\n\n// __INITIAL_STATE__来自服务器端渲染\n</pre>\n<code>\nconst initialState = window.__INITIAL_STATE__;\nconst store = configureStore(initialState);\nconst Root = (props) => &#123;\n  return (\n <pre>     <Provider store=&#123;store&#125;></pre>\n   <pre>     <Router history=&#123;createBrowserHistory()&#125;></pre>\n   <pre>       &#123;routes&#125;</pre>\n   <pre>     </Router></pre>\n   <pre>   </Provider></pre>\n  );\n&#125;\n\n<p>render(<Root />, document.getElementById(‘root’));</code></p>\n<h5 id=\"到此-客户端部分结束\"><a href=\"#到此-客户端部分结束\" class=\"headerlink\" title=\"到此 客户端部分结束\"></a>到此 客户端部分结束</h5><h4 id=\"Server-Rendering\"><a href=\"#Server-Rendering\" class=\"headerlink\" title=\"Server Rendering\"></a>Server Rendering</h4><p>获取数据调用action,routes在服务端处理参考 react-router server rendering ，在服务器端用一个match方法将拿到的request url 匹配到我们之前定义的routes，解析成和客户端一致的props对象传递给组件。</p>\n<p>服务器端渲染部分可以直接通过共用客户端 store.dispatch(action) 来统一获取 Store 数据。另外注意 renderFullPage 生成的页面 HTML 在 React 组件 mount 的部分(<div id=\"root\">)，前后端的 HTML 结构应该是一致的。然后要把 store 的状态树写入一个全局变量（__INITIAL_STATE__），这样客户端初始化 render 的时候能够校验服务器生成的 HTML 结构，并且同步到初始化状态，然后整个页面被客户端接管。</p>\n<p>页面内链接跳转处理<br>react-router 提供了一个 <Link> 组件用来替代 <a> 标签，它负责管理浏览器 history，从而不是每次点击链接都去请求服务器，然后可以通过绑定 onClick 事件来作其他处理。</p>\n<p>比如在 /list 页面，对于每一个 item 都会用 <Link> 绑定一个 route url：/item/:id，并且绑定 onClick 去触发 dispatch(fetchItem(id)) 获取数据，显示详情页内容。</p>\n"},{"title":"使用hexo+github搭建个人博客","_content":"\ntime: 2020-01-06\n\n1.首先安装 git node npm等必备\n2.安装hexo框架\n<pre>cnpm-install -g hexo-cli</pre>\n输入hexo-v验证一下是否安装成功\n<pre>hexo init blog</pre>\n<pre>npm install</pre>\n<pre>hexo server</pre>\n    快速搭建方法：\n\t<pre>npm install hexo-deployer-git --save\n\thexo clean && hexo g && hexo d</pre>\n\t\n3.在github上创建项目\n4.在文件夹下执行\n<pre>git init\ngit add.\ngit commit -m \"init blog\"\ngit remote add origin https://github.com/...\ngit push -u origin master</pre>\n\n5.在github setting中配置所购买好等域名\n\n\n\nlast：最后挑选自己配置好的主题 在hexo官网 我这里用的是一个叫做oishi的主题。\n      选到合适的主题以后需要将主题clone到项目下面的theme文件夹下面。\n\n\n\n","source":"_posts/使用hexo+github搭建个人博客.md","raw":"---\ntitle: 使用hexo+github搭建个人博客\n---\n\ntime: 2020-01-06\n\n1.首先安装 git node npm等必备\n2.安装hexo框架\n<pre>cnpm-install -g hexo-cli</pre>\n输入hexo-v验证一下是否安装成功\n<pre>hexo init blog</pre>\n<pre>npm install</pre>\n<pre>hexo server</pre>\n    快速搭建方法：\n\t<pre>npm install hexo-deployer-git --save\n\thexo clean && hexo g && hexo d</pre>\n\t\n3.在github上创建项目\n4.在文件夹下执行\n<pre>git init\ngit add.\ngit commit -m \"init blog\"\ngit remote add origin https://github.com/...\ngit push -u origin master</pre>\n\n5.在github setting中配置所购买好等域名\n\n\n\nlast：最后挑选自己配置好的主题 在hexo官网 我这里用的是一个叫做oishi的主题。\n      选到合适的主题以后需要将主题clone到项目下面的theme文件夹下面。\n\n\n\n","slug":"使用hexo+github搭建个人博客","published":1,"date":"2021-01-06T13:17:34.000Z","updated":"2021-01-06T13:17:34.000Z","_id":"cl39vusc90000kozscstqfezc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>time: 2020-01-06</p>\n<p>1.首先安装 git node npm等必备<br>2.安装hexo框架</p>\n<pre>cnpm-install -g hexo-cli</pre>\n<p>输入hexo-v验证一下是否安装成功</p>\n<pre>hexo init blog</pre>\n<pre>npm install</pre>\n<pre>hexo server</pre>\n<pre><code>快速搭建方法：\n&lt;pre&gt;npm install hexo-deployer-git --save\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d&lt;/pre&gt;</code></pre>\n<p>3.在github上创建项目<br>4.在文件夹下执行</p>\n<pre>git init\ngit add.\ngit commit -m \"init blog\"\ngit remote add origin https://github.com/...\ngit push -u origin master</pre>\n\n<p>5.在github setting中配置所购买好等域名</p>\n<p>last：最后挑选自己配置好的主题 在hexo官网 我这里用的是一个叫做oishi的主题。<br>      选到合适的主题以后需要将主题clone到项目下面的theme文件夹下面。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>time: 2020-01-06</p>\n<p>1.首先安装 git node npm等必备<br>2.安装hexo框架</p>\n<pre>cnpm-install -g hexo-cli</pre>\n<p>输入hexo-v验证一下是否安装成功</p>\n<pre>hexo init blog</pre>\n<pre>npm install</pre>\n<pre>hexo server</pre>\n<pre><code>快速搭建方法：\n&lt;pre&gt;npm install hexo-deployer-git --save\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d&lt;/pre&gt;</code></pre>\n<p>3.在github上创建项目<br>4.在文件夹下执行</p>\n<pre>git init\ngit add.\ngit commit -m \"init blog\"\ngit remote add origin https://github.com/...\ngit push -u origin master</pre>\n\n<p>5.在github setting中配置所购买好等域名</p>\n<p>last：最后挑选自己配置好的主题 在hexo官网 我这里用的是一个叫做oishi的主题。<br>      选到合适的主题以后需要将主题clone到项目下面的theme文件夹下面。</p>\n"},{"title":"常用的JavaScript方法封装","_content":"\ntime: 2020-05-17\n\n1、输入一个值，返回其数据类型**\n\n<pre>function type(para) {\n    return Object.prototype.toString.call(para)\n}</pre>\n2、数组去重\n<pre>function unique1(arr) {\n    return [...new Set(arr)]\n}\n\nfunction unique2(arr) {\n    var obj = {};\n    return arr.filter(ele => {\n        if (!obj[ele]) {\n            obj[ele] = true;\n            return true;\n        }\n    })\n}\n\nfunction unique3(arr) {\n    var result = [];\n    arr.forEach(ele => {\n        if (result.indexOf(ele) == -1) {\n            result.push(ele)\n        }\n    })\n    return result;\n}</pre>\n3、字符串去重\n<pre>String.prototype.unique = function () {\n    var obj = {},\n        str = '',\n        len = this.length;\n    for (var i = 0; i < len; i++) {\n        if (!obj[this[i]]) {\n            str += this[i];\n            obj[this[i]] = true;\n        }\n    }\n    return str;\n}\n\n//去除连续的字符串 \nfunction uniq(str) {\n    return str.replace(/(\\w)\\1+/g, '$1')\n}</pre>\n4、深拷贝 浅拷贝\n//深克隆（深克隆不考虑函数）\n<pre>function deepClone(obj, result) {\n    var result = result || {};\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            if (typeof obj[prop] == 'object' && obj[prop] !== null) {\n                // 引用值(obj/array)且不为null\n                if (Object.prototype.toString.call(obj[prop]) == '[object Object]') {\n                    // 对象\n                    result[prop] = {};\n                } else {\n                    // 数组\n                    result[prop] = [];\n                }\n                deepClone(obj[prop], result[prop])\n    } else {\n        // 原始值或func\n        result[prop] = obj[prop]\n    }\n  }\n}\nreturn result;\n}\n\n// 深浅克隆是针对引用值\nfunction deepClone(target) {\n    if (typeof (target) !== 'object') {\n        return target;\n    }\n    var result;\n    if (Object.prototype.toString.call(target) == '[object Array]') {\n        // 数组\n        result = []\n    } else {\n        // 对象\n        result = {};\n    }\n    for (var prop in target) {\n        if (target.hasOwnProperty(prop)) {\n            result[prop] = deepClone(target[prop])\n        }\n    }\n    return result;\n}\n// 无法复制函数\nvar o1 = jsON.parse(jsON.stringify(obj1));</pre>\n5、reverse底层原理和扩展\n// 改变原数组\n<pre>Array.prototype.myReverse = function () {\n    var len = this.length;\n    for (var i = 0; i < len; i++) {\n        var temp = this[i];\n        this[i] = this[len - 1 - i];\n        this[len - 1 - i] = temp;\n    }\n    return this;\n}</pre>\n6、圣杯模式的继承\n<pre>function inherit(Target, Origin) {\n    function F() {};\n    F.prototype = Origin.prototype;\n    Target.prototype = new F();\n    Target.prototype.constructor = Target;\n    // 最终的原型指向\n    Target.prop.uber = Origin.prototype;\n}</pre>\n7、找出字符串中第一次只出现一次的字母\n<pre>String.prototype.firstAppear = function () {\n    var obj = {},\n        len = this.length;\n    for (var i = 0; i < len; i++) {\n        if (obj[this[i]]) {\n            obj[this[i]]++;\n        } else {\n            obj[this[i]] = 1;\n        }\n    }\n    for (var prop in obj) {\n       if (obj[prop] == 1) {\n         return prop;\n       }\n    }\n}</pre>\n8、找元素的第n级父元素\n<pre>function parents(ele, n) {\n    while (ele && n) {\n        ele = ele.parentElement ? ele.parentElement : ele.parentNode;\n        n--;\n    }\n    return ele;\n}</pre>\n9、 返回元素的第n个兄弟节点\n<pre>function retSibling(e, n) {\n    while (e && n) {\n        if (n > 0) {\n            if (e.nextElementSibling) {\n                e = e.nextElementSibling;\n            } else {\n                for (e = e.nextSibling; e && e.nodeType !== 1; e = e.nextSibling);\n            }\n            n--;\n        } else {\n            if (e.previousElementSibling) {\n                e = e.previousElementSibling;\n            } else {\n                for (e = e.previousElementSibling; e && e.nodeType !== 1; e = e.previousElementSibling);\n            }\n            n++;\n        }\n    }\n    return e;\n}</pre>\n10、封装mychildren，解决浏览器的兼容问题\n<pre>function myChildren(e) {\n    var children = e.childNodes,\n        arr = [],\n        len = children.length;\n    for (var i = 0; i < len; i++) {\n        if (children[i].nodeType === 1) {\n            arr.push(children[i])\n        }\n    }\n    return arr;\n}</pre>\n11、判断元素有没有子元素\n<pre>function hasChildren(e) {\n    var children = e.childNodes,\n        len = children.length;\n    for (var i = 0; i < len; i++) {\n        if (children[i].nodeType === 1) {\n            return true;\n        }\n    }\n    return false;\n}</pre>\n12、我一个元素插入到另一个元素的后面\n<pre>Element.prototype.insertAfter = function (target, elen) {\n    var nextElen = elen.nextElenmentSibling;\n    if (nextElen == null) {\n        this.appendChild(target);\n    } else {\n        this.insertBefore(target, nextElen);\n    }\n}</pre>\n13、返回当前的时间（年月日时分秒）\n<pre>function getDateTime() {\n    var date = new Date(),\n        year = date.getFullYear(),\n        month = date.getMonth() + 1,\n        day = date.getDate(),\n        hour = date.getHours() + 1,\n        minute = date.getMinutes(),\n        second = date.getSeconds();\n        month = checkTime(month);\n        day = checkTime(day);\n        hour = checkTime(hour);\n        minute = checkTime(minute);\n        second = checkTime(second);\n     function checkTime(i) {\n        if (i < 10) {\n                i = \"0\" + i;\n       }\n      return i;\n    }\n    return \"\" + year + \"年\" + month + \"月\" + day + \"日\" + hour + \"时\" + minute + \"分\" + second + \"秒\"\n}</pre>\n14、获得滚动条的滚动距离\n<pre>function getScrollOffset() {\n    if (window.pageXOffset) {\n        return {\n            x: window.pageXOffset,\n            y: window.pageYOffset\n        }\n    } else {\n        return {\n            x: document.body.scrollLeft + document.documentElement.scrollLeft,\n            y: document.body.scrollTop + document.documentElement.scrollTop\n        }\n    }\n}</pre>\n15、获得视口的尺寸\n<pre>function getViewportOffset() {\n    if (window.innerWidth) {\n        return {\n            w: window.innerWidth,\n            h: window.innerHeight\n        }\n    } else {\n        // ie8及其以下\n        if (document.compatMode === \"BackCompat\") {\n            // 怪异模式\n            return {\n                w: document.body.clientWidth,\n                h: document.body.clientHeight\n            }\n        } else {\n            // 标准模式\n            return {\n                w: document.documentElement.clientWidth,\n                h: document.documentElement.clientHeight\n            }\n        }\n    }\n}</pre>\n16、获取任一元素的任意属性\n<pre>function getStyle(elem, prop) {\n    return window.getComputedStyle ? window.getComputedStyle(elem, null)[prop] : elem.currentStyle[prop]\n}</pre>\n17、绑定事件的兼容代码\n<pre>function addEvent(elem, type, handle) {\n    if (elem.addEventListener) { //非ie和非ie9\n        elem.addEventListener(type, handle, false);\n    } else if (elem.attachEvent) { //ie6到ie8\n        elem.attachEvent('on' + type, function () {\n            handle.call(elem);\n        })\n    } else {\n        elem['on' + type] = handle;\n    }\n}</pre>\n18、解绑事件\n<pre>function removeEvent(elem, type, handle) {\n    if (elem.removeEventListener) { //非ie和非ie9\n        elem.removeEventListener(type, handle, false);\n    } else if (elem.detachEvent) { //ie6到ie8\n        elem.detachEvent('on' + type, handle);\n    } else {\n        elem['on' + type] = null;\n    }\n}</pre>\n19、取消冒泡的兼容代码\n<pre>function stopBubble(e) {\n    if (e && e.stopPropagation) {\n        e.stopPropagation();\n    } else {\n        window.event.cancelBubble = true;\n    }\n}</pre>\n20、检验字符串是否是回文\n<pre>function isPalina(str) {\n    if (Object.prototype.toString.call(str) !== '[object String]') {\n        return false;\n    }\n    var len = str.length;\n    for (var i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}</pre>\n21、检验字符串是否是回文\n<pre>function isPalindrome(str) {\n    str = str.replace(/\\W/g, '').toLowerCase();\n    console.log(str)\n    return (str == str.split('').reverse().join(''))\n}</pre>\n","source":"_posts/常用的JavaScript方法封装.md","raw":"---\ntitle: 常用的JavaScript方法封装\n---\n\ntime: 2020-05-17\n\n1、输入一个值，返回其数据类型**\n\n<pre>function type(para) {\n    return Object.prototype.toString.call(para)\n}</pre>\n2、数组去重\n<pre>function unique1(arr) {\n    return [...new Set(arr)]\n}\n\nfunction unique2(arr) {\n    var obj = {};\n    return arr.filter(ele => {\n        if (!obj[ele]) {\n            obj[ele] = true;\n            return true;\n        }\n    })\n}\n\nfunction unique3(arr) {\n    var result = [];\n    arr.forEach(ele => {\n        if (result.indexOf(ele) == -1) {\n            result.push(ele)\n        }\n    })\n    return result;\n}</pre>\n3、字符串去重\n<pre>String.prototype.unique = function () {\n    var obj = {},\n        str = '',\n        len = this.length;\n    for (var i = 0; i < len; i++) {\n        if (!obj[this[i]]) {\n            str += this[i];\n            obj[this[i]] = true;\n        }\n    }\n    return str;\n}\n\n//去除连续的字符串 \nfunction uniq(str) {\n    return str.replace(/(\\w)\\1+/g, '$1')\n}</pre>\n4、深拷贝 浅拷贝\n//深克隆（深克隆不考虑函数）\n<pre>function deepClone(obj, result) {\n    var result = result || {};\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            if (typeof obj[prop] == 'object' && obj[prop] !== null) {\n                // 引用值(obj/array)且不为null\n                if (Object.prototype.toString.call(obj[prop]) == '[object Object]') {\n                    // 对象\n                    result[prop] = {};\n                } else {\n                    // 数组\n                    result[prop] = [];\n                }\n                deepClone(obj[prop], result[prop])\n    } else {\n        // 原始值或func\n        result[prop] = obj[prop]\n    }\n  }\n}\nreturn result;\n}\n\n// 深浅克隆是针对引用值\nfunction deepClone(target) {\n    if (typeof (target) !== 'object') {\n        return target;\n    }\n    var result;\n    if (Object.prototype.toString.call(target) == '[object Array]') {\n        // 数组\n        result = []\n    } else {\n        // 对象\n        result = {};\n    }\n    for (var prop in target) {\n        if (target.hasOwnProperty(prop)) {\n            result[prop] = deepClone(target[prop])\n        }\n    }\n    return result;\n}\n// 无法复制函数\nvar o1 = jsON.parse(jsON.stringify(obj1));</pre>\n5、reverse底层原理和扩展\n// 改变原数组\n<pre>Array.prototype.myReverse = function () {\n    var len = this.length;\n    for (var i = 0; i < len; i++) {\n        var temp = this[i];\n        this[i] = this[len - 1 - i];\n        this[len - 1 - i] = temp;\n    }\n    return this;\n}</pre>\n6、圣杯模式的继承\n<pre>function inherit(Target, Origin) {\n    function F() {};\n    F.prototype = Origin.prototype;\n    Target.prototype = new F();\n    Target.prototype.constructor = Target;\n    // 最终的原型指向\n    Target.prop.uber = Origin.prototype;\n}</pre>\n7、找出字符串中第一次只出现一次的字母\n<pre>String.prototype.firstAppear = function () {\n    var obj = {},\n        len = this.length;\n    for (var i = 0; i < len; i++) {\n        if (obj[this[i]]) {\n            obj[this[i]]++;\n        } else {\n            obj[this[i]] = 1;\n        }\n    }\n    for (var prop in obj) {\n       if (obj[prop] == 1) {\n         return prop;\n       }\n    }\n}</pre>\n8、找元素的第n级父元素\n<pre>function parents(ele, n) {\n    while (ele && n) {\n        ele = ele.parentElement ? ele.parentElement : ele.parentNode;\n        n--;\n    }\n    return ele;\n}</pre>\n9、 返回元素的第n个兄弟节点\n<pre>function retSibling(e, n) {\n    while (e && n) {\n        if (n > 0) {\n            if (e.nextElementSibling) {\n                e = e.nextElementSibling;\n            } else {\n                for (e = e.nextSibling; e && e.nodeType !== 1; e = e.nextSibling);\n            }\n            n--;\n        } else {\n            if (e.previousElementSibling) {\n                e = e.previousElementSibling;\n            } else {\n                for (e = e.previousElementSibling; e && e.nodeType !== 1; e = e.previousElementSibling);\n            }\n            n++;\n        }\n    }\n    return e;\n}</pre>\n10、封装mychildren，解决浏览器的兼容问题\n<pre>function myChildren(e) {\n    var children = e.childNodes,\n        arr = [],\n        len = children.length;\n    for (var i = 0; i < len; i++) {\n        if (children[i].nodeType === 1) {\n            arr.push(children[i])\n        }\n    }\n    return arr;\n}</pre>\n11、判断元素有没有子元素\n<pre>function hasChildren(e) {\n    var children = e.childNodes,\n        len = children.length;\n    for (var i = 0; i < len; i++) {\n        if (children[i].nodeType === 1) {\n            return true;\n        }\n    }\n    return false;\n}</pre>\n12、我一个元素插入到另一个元素的后面\n<pre>Element.prototype.insertAfter = function (target, elen) {\n    var nextElen = elen.nextElenmentSibling;\n    if (nextElen == null) {\n        this.appendChild(target);\n    } else {\n        this.insertBefore(target, nextElen);\n    }\n}</pre>\n13、返回当前的时间（年月日时分秒）\n<pre>function getDateTime() {\n    var date = new Date(),\n        year = date.getFullYear(),\n        month = date.getMonth() + 1,\n        day = date.getDate(),\n        hour = date.getHours() + 1,\n        minute = date.getMinutes(),\n        second = date.getSeconds();\n        month = checkTime(month);\n        day = checkTime(day);\n        hour = checkTime(hour);\n        minute = checkTime(minute);\n        second = checkTime(second);\n     function checkTime(i) {\n        if (i < 10) {\n                i = \"0\" + i;\n       }\n      return i;\n    }\n    return \"\" + year + \"年\" + month + \"月\" + day + \"日\" + hour + \"时\" + minute + \"分\" + second + \"秒\"\n}</pre>\n14、获得滚动条的滚动距离\n<pre>function getScrollOffset() {\n    if (window.pageXOffset) {\n        return {\n            x: window.pageXOffset,\n            y: window.pageYOffset\n        }\n    } else {\n        return {\n            x: document.body.scrollLeft + document.documentElement.scrollLeft,\n            y: document.body.scrollTop + document.documentElement.scrollTop\n        }\n    }\n}</pre>\n15、获得视口的尺寸\n<pre>function getViewportOffset() {\n    if (window.innerWidth) {\n        return {\n            w: window.innerWidth,\n            h: window.innerHeight\n        }\n    } else {\n        // ie8及其以下\n        if (document.compatMode === \"BackCompat\") {\n            // 怪异模式\n            return {\n                w: document.body.clientWidth,\n                h: document.body.clientHeight\n            }\n        } else {\n            // 标准模式\n            return {\n                w: document.documentElement.clientWidth,\n                h: document.documentElement.clientHeight\n            }\n        }\n    }\n}</pre>\n16、获取任一元素的任意属性\n<pre>function getStyle(elem, prop) {\n    return window.getComputedStyle ? window.getComputedStyle(elem, null)[prop] : elem.currentStyle[prop]\n}</pre>\n17、绑定事件的兼容代码\n<pre>function addEvent(elem, type, handle) {\n    if (elem.addEventListener) { //非ie和非ie9\n        elem.addEventListener(type, handle, false);\n    } else if (elem.attachEvent) { //ie6到ie8\n        elem.attachEvent('on' + type, function () {\n            handle.call(elem);\n        })\n    } else {\n        elem['on' + type] = handle;\n    }\n}</pre>\n18、解绑事件\n<pre>function removeEvent(elem, type, handle) {\n    if (elem.removeEventListener) { //非ie和非ie9\n        elem.removeEventListener(type, handle, false);\n    } else if (elem.detachEvent) { //ie6到ie8\n        elem.detachEvent('on' + type, handle);\n    } else {\n        elem['on' + type] = null;\n    }\n}</pre>\n19、取消冒泡的兼容代码\n<pre>function stopBubble(e) {\n    if (e && e.stopPropagation) {\n        e.stopPropagation();\n    } else {\n        window.event.cancelBubble = true;\n    }\n}</pre>\n20、检验字符串是否是回文\n<pre>function isPalina(str) {\n    if (Object.prototype.toString.call(str) !== '[object String]') {\n        return false;\n    }\n    var len = str.length;\n    for (var i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}</pre>\n21、检验字符串是否是回文\n<pre>function isPalindrome(str) {\n    str = str.replace(/\\W/g, '').toLowerCase();\n    console.log(str)\n    return (str == str.split('').reverse().join(''))\n}</pre>\n","slug":"常用的JavaScript方法封装","published":1,"date":"2022-05-17T08:18:42.562Z","updated":"2022-05-17T08:34:22.063Z","_id":"cl39vyndi0000tozscfzicfyt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>time: 2020-05-17</p>\n<p>1、输入一个值，返回其数据类型**</p>\n<pre>function type(para) {\n    return Object.prototype.toString.call(para)\n}</pre>\n<p>2、数组去重</p>\n<pre>function unique1(arr) {\n    return [...new Set(arr)]\n}\n\nfunction unique2(arr) {\n    var obj = {};\n    return arr.filter(ele => {\n        if (!obj[ele]) {\n            obj[ele] = true;\n            return true;\n        }\n    })\n}\n\nfunction unique3(arr) {\n    var result = [];\n    arr.forEach(ele => {\n        if (result.indexOf(ele) == -1) {\n            result.push(ele)\n        }\n    })\n    return result;\n}</pre>\n<p>3、字符串去重</p>\n<pre>String.prototype.unique = function () {\n    var obj = {},\n        str = '',\n        len = this.length;\n    for (var i = 0; i < len; i++) {\n        if (!obj[this[i]]) {\n            str += this[i];\n            obj[this[i]] = true;\n        }\n    }\n    return str;\n}\n\n//去除连续的字符串 \nfunction uniq(str) {\n    return str.replace(/(\\w)\\1+/g, '$1')\n}</pre>\n<p>4、深拷贝 浅拷贝<br>//深克隆（深克隆不考虑函数）</p>\n<pre>function deepClone(obj, result) {\n    var result = result || {};\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            if (typeof obj[prop] == 'object' && obj[prop] !== null) {\n                // 引用值(obj/array)且不为null\n                if (Object.prototype.toString.call(obj[prop]) == '[object Object]') {\n                    // 对象\n                    result[prop] = {};\n                } else {\n                    // 数组\n                    result[prop] = [];\n                }\n                deepClone(obj[prop], result[prop])\n    } else {\n        // 原始值或func\n        result[prop] = obj[prop]\n    }\n  }\n}\nreturn result;\n}\n\n// 深浅克隆是针对引用值\nfunction deepClone(target) {\n    if (typeof (target) !== 'object') {\n        return target;\n    }\n    var result;\n    if (Object.prototype.toString.call(target) == '[object Array]') {\n        // 数组\n        result = []\n    } else {\n        // 对象\n        result = {};\n    }\n    for (var prop in target) {\n        if (target.hasOwnProperty(prop)) {\n            result[prop] = deepClone(target[prop])\n        }\n    }\n    return result;\n}\n// 无法复制函数\nvar o1 = jsON.parse(jsON.stringify(obj1));</pre>\n<p>5、reverse底层原理和扩展<br>// 改变原数组</p>\n<pre>Array.prototype.myReverse = function () {\n    var len = this.length;\n    for (var i = 0; i < len; i++) {\n        var temp = this[i];\n        this[i] = this[len - 1 - i];\n        this[len - 1 - i] = temp;\n    }\n    return this;\n}</pre>\n<p>6、圣杯模式的继承</p>\n<pre>function inherit(Target, Origin) {\n    function F() {};\n    F.prototype = Origin.prototype;\n    Target.prototype = new F();\n    Target.prototype.constructor = Target;\n    // 最终的原型指向\n    Target.prop.uber = Origin.prototype;\n}</pre>\n<p>7、找出字符串中第一次只出现一次的字母</p>\n<pre>String.prototype.firstAppear = function () {\n    var obj = {},\n        len = this.length;\n    for (var i = 0; i < len; i++) {\n        if (obj[this[i]]) {\n            obj[this[i]]++;\n        } else {\n            obj[this[i]] = 1;\n        }\n    }\n    for (var prop in obj) {\n       if (obj[prop] == 1) {\n         return prop;\n       }\n    }\n}</pre>\n<p>8、找元素的第n级父元素</p>\n<pre>function parents(ele, n) {\n    while (ele && n) {\n        ele = ele.parentElement ? ele.parentElement : ele.parentNode;\n        n--;\n    }\n    return ele;\n}</pre>\n<p>9、 返回元素的第n个兄弟节点</p>\n<pre>function retSibling(e, n) {\n    while (e && n) {\n        if (n > 0) {\n            if (e.nextElementSibling) {\n                e = e.nextElementSibling;\n            } else {\n                for (e = e.nextSibling; e && e.nodeType !== 1; e = e.nextSibling);\n            }\n            n--;\n        } else {\n            if (e.previousElementSibling) {\n                e = e.previousElementSibling;\n            } else {\n                for (e = e.previousElementSibling; e && e.nodeType !== 1; e = e.previousElementSibling);\n            }\n            n++;\n        }\n    }\n    return e;\n}</pre>\n<p>10、封装mychildren，解决浏览器的兼容问题</p>\n<pre>function myChildren(e) {\n    var children = e.childNodes,\n        arr = [],\n        len = children.length;\n    for (var i = 0; i < len; i++) {\n        if (children[i].nodeType === 1) {\n            arr.push(children[i])\n        }\n    }\n    return arr;\n}</pre>\n<p>11、判断元素有没有子元素</p>\n<pre>function hasChildren(e) {\n    var children = e.childNodes,\n        len = children.length;\n    for (var i = 0; i < len; i++) {\n        if (children[i].nodeType === 1) {\n            return true;\n        }\n    }\n    return false;\n}</pre>\n<p>12、我一个元素插入到另一个元素的后面</p>\n<pre>Element.prototype.insertAfter = function (target, elen) {\n    var nextElen = elen.nextElenmentSibling;\n    if (nextElen == null) {\n        this.appendChild(target);\n    } else {\n        this.insertBefore(target, nextElen);\n    }\n}</pre>\n<p>13、返回当前的时间（年月日时分秒）</p>\n<pre>function getDateTime() {\n    var date = new Date(),\n        year = date.getFullYear(),\n        month = date.getMonth() + 1,\n        day = date.getDate(),\n        hour = date.getHours() + 1,\n        minute = date.getMinutes(),\n        second = date.getSeconds();\n        month = checkTime(month);\n        day = checkTime(day);\n        hour = checkTime(hour);\n        minute = checkTime(minute);\n        second = checkTime(second);\n     function checkTime(i) {\n        if (i < 10) {\n                i = \"0\" + i;\n       }\n      return i;\n    }\n    return \"\" + year + \"年\" + month + \"月\" + day + \"日\" + hour + \"时\" + minute + \"分\" + second + \"秒\"\n}</pre>\n<p>14、获得滚动条的滚动距离</p>\n<pre>function getScrollOffset() {\n    if (window.pageXOffset) {\n        return {\n            x: window.pageXOffset,\n            y: window.pageYOffset\n        }\n    } else {\n        return {\n            x: document.body.scrollLeft + document.documentElement.scrollLeft,\n            y: document.body.scrollTop + document.documentElement.scrollTop\n        }\n    }\n}</pre>\n<p>15、获得视口的尺寸</p>\n<pre>function getViewportOffset() {\n    if (window.innerWidth) {\n        return {\n            w: window.innerWidth,\n            h: window.innerHeight\n        }\n    } else {\n        // ie8及其以下\n        if (document.compatMode === \"BackCompat\") {\n            // 怪异模式\n            return {\n                w: document.body.clientWidth,\n                h: document.body.clientHeight\n            }\n        } else {\n            // 标准模式\n            return {\n                w: document.documentElement.clientWidth,\n                h: document.documentElement.clientHeight\n            }\n        }\n    }\n}</pre>\n<p>16、获取任一元素的任意属性</p>\n<pre>function getStyle(elem, prop) {\n    return window.getComputedStyle ? window.getComputedStyle(elem, null)[prop] : elem.currentStyle[prop]\n}</pre>\n<p>17、绑定事件的兼容代码</p>\n<pre>function addEvent(elem, type, handle) {\n    if (elem.addEventListener) { //非ie和非ie9\n        elem.addEventListener(type, handle, false);\n    } else if (elem.attachEvent) { //ie6到ie8\n        elem.attachEvent('on' + type, function () {\n            handle.call(elem);\n        })\n    } else {\n        elem['on' + type] = handle;\n    }\n}</pre>\n<p>18、解绑事件</p>\n<pre>function removeEvent(elem, type, handle) {\n    if (elem.removeEventListener) { //非ie和非ie9\n        elem.removeEventListener(type, handle, false);\n    } else if (elem.detachEvent) { //ie6到ie8\n        elem.detachEvent('on' + type, handle);\n    } else {\n        elem['on' + type] = null;\n    }\n}</pre>\n<p>19、取消冒泡的兼容代码</p>\n<pre>function stopBubble(e) {\n    if (e && e.stopPropagation) {\n        e.stopPropagation();\n    } else {\n        window.event.cancelBubble = true;\n    }\n}</pre>\n<p>20、检验字符串是否是回文</p>\n<pre>function isPalina(str) {\n    if (Object.prototype.toString.call(str) !== '[object String]') {\n        return false;\n    }\n    var len = str.length;\n    for (var i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}</pre>\n<p>21、检验字符串是否是回文</p>\n<pre>function isPalindrome(str) {\n    str = str.replace(/\\W/g, '').toLowerCase();\n    console.log(str)\n    return (str == str.split('').reverse().join(''))\n}</pre>\n","site":{"data":{}},"excerpt":"","more":"<p>time: 2020-05-17</p>\n<p>1、输入一个值，返回其数据类型**</p>\n<pre>function type(para) {\n    return Object.prototype.toString.call(para)\n}</pre>\n<p>2、数组去重</p>\n<pre>function unique1(arr) {\n    return [...new Set(arr)]\n}\n\nfunction unique2(arr) {\n    var obj = {};\n    return arr.filter(ele => {\n        if (!obj[ele]) {\n            obj[ele] = true;\n            return true;\n        }\n    })\n}\n\nfunction unique3(arr) {\n    var result = [];\n    arr.forEach(ele => {\n        if (result.indexOf(ele) == -1) {\n            result.push(ele)\n        }\n    })\n    return result;\n}</pre>\n<p>3、字符串去重</p>\n<pre>String.prototype.unique = function () {\n    var obj = {},\n        str = '',\n        len = this.length;\n    for (var i = 0; i < len; i++) {\n        if (!obj[this[i]]) {\n            str += this[i];\n            obj[this[i]] = true;\n        }\n    }\n    return str;\n}\n\n//去除连续的字符串 \nfunction uniq(str) {\n    return str.replace(/(\\w)\\1+/g, '$1')\n}</pre>\n<p>4、深拷贝 浅拷贝<br>//深克隆（深克隆不考虑函数）</p>\n<pre>function deepClone(obj, result) {\n    var result = result || {};\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            if (typeof obj[prop] == 'object' && obj[prop] !== null) {\n                // 引用值(obj/array)且不为null\n                if (Object.prototype.toString.call(obj[prop]) == '[object Object]') {\n                    // 对象\n                    result[prop] = {};\n                } else {\n                    // 数组\n                    result[prop] = [];\n                }\n                deepClone(obj[prop], result[prop])\n    } else {\n        // 原始值或func\n        result[prop] = obj[prop]\n    }\n  }\n}\nreturn result;\n}\n\n// 深浅克隆是针对引用值\nfunction deepClone(target) {\n    if (typeof (target) !== 'object') {\n        return target;\n    }\n    var result;\n    if (Object.prototype.toString.call(target) == '[object Array]') {\n        // 数组\n        result = []\n    } else {\n        // 对象\n        result = {};\n    }\n    for (var prop in target) {\n        if (target.hasOwnProperty(prop)) {\n            result[prop] = deepClone(target[prop])\n        }\n    }\n    return result;\n}\n// 无法复制函数\nvar o1 = jsON.parse(jsON.stringify(obj1));</pre>\n<p>5、reverse底层原理和扩展<br>// 改变原数组</p>\n<pre>Array.prototype.myReverse = function () {\n    var len = this.length;\n    for (var i = 0; i < len; i++) {\n        var temp = this[i];\n        this[i] = this[len - 1 - i];\n        this[len - 1 - i] = temp;\n    }\n    return this;\n}</pre>\n<p>6、圣杯模式的继承</p>\n<pre>function inherit(Target, Origin) {\n    function F() {};\n    F.prototype = Origin.prototype;\n    Target.prototype = new F();\n    Target.prototype.constructor = Target;\n    // 最终的原型指向\n    Target.prop.uber = Origin.prototype;\n}</pre>\n<p>7、找出字符串中第一次只出现一次的字母</p>\n<pre>String.prototype.firstAppear = function () {\n    var obj = {},\n        len = this.length;\n    for (var i = 0; i < len; i++) {\n        if (obj[this[i]]) {\n            obj[this[i]]++;\n        } else {\n            obj[this[i]] = 1;\n        }\n    }\n    for (var prop in obj) {\n       if (obj[prop] == 1) {\n         return prop;\n       }\n    }\n}</pre>\n<p>8、找元素的第n级父元素</p>\n<pre>function parents(ele, n) {\n    while (ele && n) {\n        ele = ele.parentElement ? ele.parentElement : ele.parentNode;\n        n--;\n    }\n    return ele;\n}</pre>\n<p>9、 返回元素的第n个兄弟节点</p>\n<pre>function retSibling(e, n) {\n    while (e && n) {\n        if (n > 0) {\n            if (e.nextElementSibling) {\n                e = e.nextElementSibling;\n            } else {\n                for (e = e.nextSibling; e && e.nodeType !== 1; e = e.nextSibling);\n            }\n            n--;\n        } else {\n            if (e.previousElementSibling) {\n                e = e.previousElementSibling;\n            } else {\n                for (e = e.previousElementSibling; e && e.nodeType !== 1; e = e.previousElementSibling);\n            }\n            n++;\n        }\n    }\n    return e;\n}</pre>\n<p>10、封装mychildren，解决浏览器的兼容问题</p>\n<pre>function myChildren(e) {\n    var children = e.childNodes,\n        arr = [],\n        len = children.length;\n    for (var i = 0; i < len; i++) {\n        if (children[i].nodeType === 1) {\n            arr.push(children[i])\n        }\n    }\n    return arr;\n}</pre>\n<p>11、判断元素有没有子元素</p>\n<pre>function hasChildren(e) {\n    var children = e.childNodes,\n        len = children.length;\n    for (var i = 0; i < len; i++) {\n        if (children[i].nodeType === 1) {\n            return true;\n        }\n    }\n    return false;\n}</pre>\n<p>12、我一个元素插入到另一个元素的后面</p>\n<pre>Element.prototype.insertAfter = function (target, elen) {\n    var nextElen = elen.nextElenmentSibling;\n    if (nextElen == null) {\n        this.appendChild(target);\n    } else {\n        this.insertBefore(target, nextElen);\n    }\n}</pre>\n<p>13、返回当前的时间（年月日时分秒）</p>\n<pre>function getDateTime() {\n    var date = new Date(),\n        year = date.getFullYear(),\n        month = date.getMonth() + 1,\n        day = date.getDate(),\n        hour = date.getHours() + 1,\n        minute = date.getMinutes(),\n        second = date.getSeconds();\n        month = checkTime(month);\n        day = checkTime(day);\n        hour = checkTime(hour);\n        minute = checkTime(minute);\n        second = checkTime(second);\n     function checkTime(i) {\n        if (i < 10) {\n                i = \"0\" + i;\n       }\n      return i;\n    }\n    return \"\" + year + \"年\" + month + \"月\" + day + \"日\" + hour + \"时\" + minute + \"分\" + second + \"秒\"\n}</pre>\n<p>14、获得滚动条的滚动距离</p>\n<pre>function getScrollOffset() {\n    if (window.pageXOffset) {\n        return {\n            x: window.pageXOffset,\n            y: window.pageYOffset\n        }\n    } else {\n        return {\n            x: document.body.scrollLeft + document.documentElement.scrollLeft,\n            y: document.body.scrollTop + document.documentElement.scrollTop\n        }\n    }\n}</pre>\n<p>15、获得视口的尺寸</p>\n<pre>function getViewportOffset() {\n    if (window.innerWidth) {\n        return {\n            w: window.innerWidth,\n            h: window.innerHeight\n        }\n    } else {\n        // ie8及其以下\n        if (document.compatMode === \"BackCompat\") {\n            // 怪异模式\n            return {\n                w: document.body.clientWidth,\n                h: document.body.clientHeight\n            }\n        } else {\n            // 标准模式\n            return {\n                w: document.documentElement.clientWidth,\n                h: document.documentElement.clientHeight\n            }\n        }\n    }\n}</pre>\n<p>16、获取任一元素的任意属性</p>\n<pre>function getStyle(elem, prop) {\n    return window.getComputedStyle ? window.getComputedStyle(elem, null)[prop] : elem.currentStyle[prop]\n}</pre>\n<p>17、绑定事件的兼容代码</p>\n<pre>function addEvent(elem, type, handle) {\n    if (elem.addEventListener) { //非ie和非ie9\n        elem.addEventListener(type, handle, false);\n    } else if (elem.attachEvent) { //ie6到ie8\n        elem.attachEvent('on' + type, function () {\n            handle.call(elem);\n        })\n    } else {\n        elem['on' + type] = handle;\n    }\n}</pre>\n<p>18、解绑事件</p>\n<pre>function removeEvent(elem, type, handle) {\n    if (elem.removeEventListener) { //非ie和非ie9\n        elem.removeEventListener(type, handle, false);\n    } else if (elem.detachEvent) { //ie6到ie8\n        elem.detachEvent('on' + type, handle);\n    } else {\n        elem['on' + type] = null;\n    }\n}</pre>\n<p>19、取消冒泡的兼容代码</p>\n<pre>function stopBubble(e) {\n    if (e && e.stopPropagation) {\n        e.stopPropagation();\n    } else {\n        window.event.cancelBubble = true;\n    }\n}</pre>\n<p>20、检验字符串是否是回文</p>\n<pre>function isPalina(str) {\n    if (Object.prototype.toString.call(str) !== '[object String]') {\n        return false;\n    }\n    var len = str.length;\n    for (var i = 0; i < len / 2; i++) {\n        if (str[i] != str[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}</pre>\n<p>21、检验字符串是否是回文</p>\n<pre>function isPalindrome(str) {\n    str = str.replace(/\\W/g, '').toLowerCase();\n    console.log(str)\n    return (str == str.split('').reverse().join(''))\n}</pre>\n"},{"title":"常用的JavaScript方法封装-2","_content":"\ntime: 2020-05-18\n\n\n\n22、兼容getElementsByClassName方法\n<pre>Element.prototype.getElementsByClassName = Document.prototype.getElementsByClassName = function (_className) {\n    var allDomArray = document.getElementsByTagName('*');\n    var lastDomArray = [];\n    function trimSpace(strClass) {\n        var reg = /\\s+/g;\n        return strClass.replace(reg, ' ').trim()\n    }\n    for (var i = 0; i < allDomArray.length; i++) {\n        var classArray = trimSpace(allDomArray[i].className).split(' ');\n        for (var j = 0; j < classArray.length; j++) {\n            if (classArray[j] == _className) {\n                lastDomArray.push(allDomArray[i]);\n                break;\n            }\n        }\n    }\n    return lastDomArray;\n}</pre>\n23、运动函数\n<pre>function animate(obj, json, callback) {\n    clearInterval(obj.timer);\n    var speed,\n        current;\n    obj.timer = setInterval(function () {\n        var lock = true;\n        for (var prop in json) {\n            if (prop == 'opacity') {\n                current = parseFloat(window.getComputedStyle(obj, null)[prop]) * 100;\n            } else {\n                current = parseInt(window.getComputedStyle(obj, null)[prop]);\n            }\n            speed = (json[prop] - current) / 7;\n            speed = speed > 0 ? Math.ceil(speed) : Math.floor(speed);\n\n            if (prop == 'opacity') {\n                obj.style[prop] = (current + speed) / 100;\n            } else {\n                obj.style[prop] = current + speed + 'px';\n            }\n            if (current != json[prop]) {\n                lock = false;\n            }\n        }\n        if (lock) {\n            clearInterval(obj.timer);\n            typeof callback == 'function' ? callback() : '';\n        }\n    }, 30)\n}</pre>\n24、弹性运动\n<pre>function ElasticMovement(obj, target) {\n    clearInterval(obj.timer);\n    var iSpeed = 40,\n        a, u = 0.8;\n    obj.timer = setInterval(function () {\n        a = (target - obj.offsetLeft) / 8;\n        iSpeed = iSpeed + a;\n        iSpeed = iSpeed * u;\n        if (Math.abs(iSpeed) <= 1 && Math.abs(a) <= 1) {\n            console.log('over')\n            clearInterval(obj.timer);\n            obj.style.left = target + 'px';\n        } else {\n            obj.style.left = obj.offsetLeft + iSpeed + 'px';\n        }\n    }, 30);\n}</pre>\n25、封装自己的forEach方法\n<pre>Array.prototype.myForEach = function (func, obj) {\n    var len = this.length;\n    var _this = arguments[1] ? arguments[1] : window;\n    // var _this=arguments[1]||window;\n    for (var i = 0; i < len; i++) {\n        func.call(_this, this[i], i, this)\n    }\n}</pre>\n26、封装自己的filter方法\n<pre>Array.prototype.myFilter = function (func, obj) {\n    var len = this.length;\n    var arr = [];\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        func.call(_this, this[i], i, this) && arr.push(this[i]);\n    }\n    return arr;\n}</pre>\n27、数组map方法\n<pre>Array.prototype.myMap = function (func) {\n    var arr = [];\n    var len = this.length;\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        arr.push(func.call(_this, this[i], i, this));\n    }\n    return arr;\n}</pre>\n28、数组every方法\n<pre>Array.prototype.myEvery = function (func) {\n    var flag = true;\n    var len = this.length;\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        if (func.apply(_this, [this[i], i, this]) == false) {\n            flag = false;\n            break;\n        }\n    }\n    return flag;\n}</pre>\n29、数组reduce方法\n<pre>Array.prototype.myReduce = function (func, initialValue) {\n    var len = this.length,\n        nextValue,\n        i;\n    if (!initialValue) {\n        // 没有传第二个参数\n        nextValue = this[0];\n        i = 1;\n    } else {\n        // 传了第二个参数\n        nextValue = initialValue;\n        i = 0;\n    }\n    for (; i < len; i++) {\n        nextValue = func(nextValue, this[i], i, this);\n    }\n    return nextValue;\n}</pre>\n30、获取url中的参数\n<pre>function getWindonHref() {\n    var sHref = window.location.href;\n    var args = sHref.split('?');\n    if (args[0] === sHref) {\n        return '';\n    }\n    var hrefarr = args[1].split('#')[0].split('&');\n    var obj = {};\n    for (var i = 0; i < hrefarr.length; i++) {\n        hrefarr[i] = hrefarr[i].split('=');\n        obj[hrefarr[i][0]] = hrefarr[i][1];\n    }\n    return obj;\n}</pre>\n31、数组排序\n<pre>// 快排 [left] + min + [right]\nfunction quickArr(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    var left = [],\n        right = [];\n    var pIndex = Math.floor(arr.length / 2);\n    var p = arr.splice(pIndex, 1)[0];\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] <= p) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    // 递归\n    return quickArr(left).concat([p], quickArr(right));\n}\n\n// 冒泡\nfunction bubbleSort(arr) {\n    for (var i = 0; i < arr.length - 1; i++) {\n        for (var j = i + 1; j < arr.length; j++) {\n            if (arr[i] > arr[j]) {\n                var temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\n\nfunction bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i < len - 1; i++) {\n        for (var j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                var temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n    return arr;\n}</pre>\n32、遍历Dom树\n<pre>// 给定页面上的DOM元素,将访问元素本身及其所有后代(不仅仅是它的直接子元素)\n// 对于每个访问的元素，函数讲元素传递给提供的回调函数\nfunction traverse(element, callback) {\n    callback(element);\n    var list = element.children;\n    for (var i = 0; i < list.length; i++) {\n        traverse(list[i], callback);\n    }\n}</pre>\n33、原生js封装ajax\n<pre>function ajax(method, url, callback, data, flag) {\n    var xhr;\n    flag = flag || true;\n    method = method.toUpperCase();\n    if (window.XMLHttpRequest) {\n        xhr = new XMLHttpRequest();\n    } else {\n        xhr = new ActiveXObject('Microsoft.XMLHttp');\n    }\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4 && xhr.status == 200) {\n            console.log(2)\n            callback(xhr.responseText);\n        }\n    }\n\n    if (method == 'GET') {\n        var date = new Date(),\n        timer = date.getTime();\n        xhr.open('GET', url + '?' + data + '&timer' + timer, flag);\n        xhr.send()\n        } else if (method == 'POST') {\n        xhr.open('POST', url, flag);\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        xhr.send(data);\n    }\n}</pre>\n34、异步加载script\n<pre>function loadScript(url, callback) {\n    var oscript = document.createElement('script');\n    if (oscript.readyState) { // ie8及以下版本\n        oscript.onreadystatechange = function () {\n            if (oscript.readyState === 'complete' || oscript.readyState === 'loaded') {\n                callback();\n            }\n        }\n    } else {\n        oscript.onload = function () {\n            callback()\n        };\n    }\n    oscript.src = url;\n    document.body.appendChild(oscript);\n}</pre>\n35、cookie管理\n<pre>var cookie = {\n    set: function (name, value, time) {\n        document.cookie = name + '=' + value + '; max-age=' + time;\n        return this;\n    },\n    remove: function (name) {\n        return this.setCookie(name, '', -1);\n    },\n    get: function (name, callback) {\n        var allCookieArr = document.cookie.split('; ');\n        for (var i = 0; i < allCookieArr.length; i++) {\n            var itemCookieArr = allCookieArr[i].split('=');\n            if (itemCookieArr[0] === name) {\n                return itemCookieArr[1]\n            }\n        }\n        return undefined;\n    }\n}</pre>\n36、实现bind()方法\n<pre>Function.prototype.myBind = function (target) {\n    var target = target || window;\n    var _args1 = [].slice.call(arguments, 1);\n    var self = this;\n    var temp = function () {};\n    var F = function () {\n        var _args2 = [].slice.call(arguments, 0);\n        var parasArr = _args1.concat(_args2);\n        return self.apply(this instanceof temp ? this : target, parasArr)\n    }\n    temp.prototype = self.prototype;\n    F.prototype = new temp();\n    return F;\n}</pre>\n37、实现call()方法\n<pre>Function.prototype.myCall = function () {\n    var ctx = arguments[0] || window;\n    ctx.fn = this;\n    var args = [];\n    for (var i = 1; i < arguments.length; i++) {\n        args.push(arguments[i])\n    }\n    var result = ctx.fn(...args);\n    delete ctx.fn;\n    return result;\n}</pre>\n38、实现apply()方法\n<pre>Function.prototype.myApply = function () {\n    var ctx = arguments[0] || window;\n    ctx.fn = this;\n    if (!arguments[1]) {\n        var result = ctx.fn();\n        delete ctx.fn;\n        return result;\n    }\n    var result = ctx.fn(...arguments[1]);\n    delete ctx.fn;\n    return result;\n}</pre>\n39、防抖\n<pre>function debounce(handle, delay) {\n    var timer = null;\n    return function () {\n        var _self = this,\n            _args = arguments;\n        clearTimeout(timer);\n        timer = setTimeout(function () {\n            handle.apply(_self, _args)\n        }, delay)\n    }\n}</pre>\n40、节流\n<pre>function throttle(handler, wait) {\n    var lastTime = 0;\n    return function (e) {\n        var nowTime = new Date().getTime();\n        if (nowTime - lastTime > wait) {\n            handler.apply(this, arguments);\n            lastTime = nowTime;\n        }\n    }\n}</pre>\n41、requestAnimFrame兼容性方法\n<pre>window.requestAnimFrame = (function () {\n    return window.requestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        function (callback) {\n            window.setTimeout(callback, 1000 / 60);\n        };\n})();</pre>\n42、cancelAnimFrame兼容性方法\n<pre>window.cancelAnimFrame = (function () {\n    return window.cancelAnimationFrame ||\n        window.webkitCancelAnimationFrame ||\n        window.mozCancelAnimationFrame ||\n        function (id) {\n            window.clearTimeout(id);\n        };\n})();</pre>\n43、jsonp底层方法\n<pre>function jsonp(url, callback) {\n    var oscript = document.createElement('script');\n    if (oscript.readyState) { // ie8及以下版本\n        oscript.onreadystatechange = function () {\n            if (oscript.readyState === 'complete' || oscript.readyState === 'loaded') {\n                callback();\n            }\n        }\n    } else {\n        oscript.onload = function () {\n            callback()\n        };\n    }\n    oscript.src = url;\n    document.body.appendChild(oscript);\n}</pre>\n44、获取url上的参数\n<pre>function getUrlParam(sUrl, sKey) {\n    var result = {};\n    sUrl.replace(/(\\w+)=(\\w+)(?=[&|#])/g, function (ele, key, val) {\n        if (!result[key]) {\n            result[key] = val;\n        } else {\n            var temp = result[key];\n            result[key] = [].concat(temp, val);\n        }\n    })\n    if (!sKey) {\n        return result;\n    } else {\n        return result[sKey] || '';\n    }\n}</pre>\n45、格式化时间\n<pre>function formatDate(t, str) {\n    var obj = {\n        yyyy: t.getFullYear(),\n        yy: (\"\" + t.getFullYear()).slice(-2),\n        M: t.getMonth() + 1,\n        MM: (\"0\" + (t.getMonth() + 1)).slice(-2),\n        d: t.getDate(),\n        dd: (\"0\" + t.getDate()).slice(-2),\n        H: t.getHours(),\n        HH: (\"0\" + t.getHours()).slice(-2),\n        h: t.getHours() % 12,\n        hh: (\"0\" + t.getHours() % 12).slice(-2),\n        m: t.getMinutes(),\n        mm: (\"0\" + t.getMinutes()).slice(-2),\n        s: t.getSeconds(),\n        ss: (\"0\" + t.getSeconds()).slice(-2),\n        w: ['日', '一', '二', '三', '四', '五', '六'][t.getDay()]\n    };\n    return str.replace(/([a-z]+)/ig, function ($1) {\n        return obj[$1]\n    });\n}</pre>\n46、验证邮箱的正则表达式\n<pre>function isAvailableEmail(sEmail) {\n    var reg = /^([\\w+\\.])+@\\w+([.]\\w+)+$/\n    return reg.test(sEmail)\n}</pre>\n47、函数柯里化\n<pre>//是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术\n\nfunction curryIt(fn) {\n    var length = fn.length,\n        args = [];\n    var result = function (arg) {\n        args.push(arg);\n        length--;\n        if (length <= 0) {\n            return fn.apply(this, args);\n        } else {\n            return result;\n        }\n    }\n    return result;\n}</pre>\n48、大数相加\n<pre>function sumBigNumber(a, b) {\n    var res = '', //结果\n        temp = 0; //按位加的结果及进位\n    a = a.split('');\n    b = b.split('');\n    while (a.length || b.length || temp) {\n        //~~按位非 1.类型转换，转换成数字 2.~~undefined==0 \n        temp += ~~a.pop() + ~~b.pop();\n        res = (temp % 10) + res;\n        temp = temp > 9;\n    }\n    return res.replace(/^0+/, '');\n}</pre>\n49、单例模式\n<pre>function getSingle(func) {\n    var result;\n    return function () {\n        if (!result) {\n            result = new func(arguments);\n        }\n        return result;\n    }\n}</pre>","source":"_posts/常用的JavaScript方法封装2.md","raw":"---\ntitle: 常用的JavaScript方法封装-2\n---\n\ntime: 2020-05-18\n\n\n\n22、兼容getElementsByClassName方法\n<pre>Element.prototype.getElementsByClassName = Document.prototype.getElementsByClassName = function (_className) {\n    var allDomArray = document.getElementsByTagName('*');\n    var lastDomArray = [];\n    function trimSpace(strClass) {\n        var reg = /\\s+/g;\n        return strClass.replace(reg, ' ').trim()\n    }\n    for (var i = 0; i < allDomArray.length; i++) {\n        var classArray = trimSpace(allDomArray[i].className).split(' ');\n        for (var j = 0; j < classArray.length; j++) {\n            if (classArray[j] == _className) {\n                lastDomArray.push(allDomArray[i]);\n                break;\n            }\n        }\n    }\n    return lastDomArray;\n}</pre>\n23、运动函数\n<pre>function animate(obj, json, callback) {\n    clearInterval(obj.timer);\n    var speed,\n        current;\n    obj.timer = setInterval(function () {\n        var lock = true;\n        for (var prop in json) {\n            if (prop == 'opacity') {\n                current = parseFloat(window.getComputedStyle(obj, null)[prop]) * 100;\n            } else {\n                current = parseInt(window.getComputedStyle(obj, null)[prop]);\n            }\n            speed = (json[prop] - current) / 7;\n            speed = speed > 0 ? Math.ceil(speed) : Math.floor(speed);\n\n            if (prop == 'opacity') {\n                obj.style[prop] = (current + speed) / 100;\n            } else {\n                obj.style[prop] = current + speed + 'px';\n            }\n            if (current != json[prop]) {\n                lock = false;\n            }\n        }\n        if (lock) {\n            clearInterval(obj.timer);\n            typeof callback == 'function' ? callback() : '';\n        }\n    }, 30)\n}</pre>\n24、弹性运动\n<pre>function ElasticMovement(obj, target) {\n    clearInterval(obj.timer);\n    var iSpeed = 40,\n        a, u = 0.8;\n    obj.timer = setInterval(function () {\n        a = (target - obj.offsetLeft) / 8;\n        iSpeed = iSpeed + a;\n        iSpeed = iSpeed * u;\n        if (Math.abs(iSpeed) <= 1 && Math.abs(a) <= 1) {\n            console.log('over')\n            clearInterval(obj.timer);\n            obj.style.left = target + 'px';\n        } else {\n            obj.style.left = obj.offsetLeft + iSpeed + 'px';\n        }\n    }, 30);\n}</pre>\n25、封装自己的forEach方法\n<pre>Array.prototype.myForEach = function (func, obj) {\n    var len = this.length;\n    var _this = arguments[1] ? arguments[1] : window;\n    // var _this=arguments[1]||window;\n    for (var i = 0; i < len; i++) {\n        func.call(_this, this[i], i, this)\n    }\n}</pre>\n26、封装自己的filter方法\n<pre>Array.prototype.myFilter = function (func, obj) {\n    var len = this.length;\n    var arr = [];\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        func.call(_this, this[i], i, this) && arr.push(this[i]);\n    }\n    return arr;\n}</pre>\n27、数组map方法\n<pre>Array.prototype.myMap = function (func) {\n    var arr = [];\n    var len = this.length;\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        arr.push(func.call(_this, this[i], i, this));\n    }\n    return arr;\n}</pre>\n28、数组every方法\n<pre>Array.prototype.myEvery = function (func) {\n    var flag = true;\n    var len = this.length;\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        if (func.apply(_this, [this[i], i, this]) == false) {\n            flag = false;\n            break;\n        }\n    }\n    return flag;\n}</pre>\n29、数组reduce方法\n<pre>Array.prototype.myReduce = function (func, initialValue) {\n    var len = this.length,\n        nextValue,\n        i;\n    if (!initialValue) {\n        // 没有传第二个参数\n        nextValue = this[0];\n        i = 1;\n    } else {\n        // 传了第二个参数\n        nextValue = initialValue;\n        i = 0;\n    }\n    for (; i < len; i++) {\n        nextValue = func(nextValue, this[i], i, this);\n    }\n    return nextValue;\n}</pre>\n30、获取url中的参数\n<pre>function getWindonHref() {\n    var sHref = window.location.href;\n    var args = sHref.split('?');\n    if (args[0] === sHref) {\n        return '';\n    }\n    var hrefarr = args[1].split('#')[0].split('&');\n    var obj = {};\n    for (var i = 0; i < hrefarr.length; i++) {\n        hrefarr[i] = hrefarr[i].split('=');\n        obj[hrefarr[i][0]] = hrefarr[i][1];\n    }\n    return obj;\n}</pre>\n31、数组排序\n<pre>// 快排 [left] + min + [right]\nfunction quickArr(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    var left = [],\n        right = [];\n    var pIndex = Math.floor(arr.length / 2);\n    var p = arr.splice(pIndex, 1)[0];\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] <= p) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    // 递归\n    return quickArr(left).concat([p], quickArr(right));\n}\n\n// 冒泡\nfunction bubbleSort(arr) {\n    for (var i = 0; i < arr.length - 1; i++) {\n        for (var j = i + 1; j < arr.length; j++) {\n            if (arr[i] > arr[j]) {\n                var temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\n\nfunction bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i < len - 1; i++) {\n        for (var j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                var temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n    return arr;\n}</pre>\n32、遍历Dom树\n<pre>// 给定页面上的DOM元素,将访问元素本身及其所有后代(不仅仅是它的直接子元素)\n// 对于每个访问的元素，函数讲元素传递给提供的回调函数\nfunction traverse(element, callback) {\n    callback(element);\n    var list = element.children;\n    for (var i = 0; i < list.length; i++) {\n        traverse(list[i], callback);\n    }\n}</pre>\n33、原生js封装ajax\n<pre>function ajax(method, url, callback, data, flag) {\n    var xhr;\n    flag = flag || true;\n    method = method.toUpperCase();\n    if (window.XMLHttpRequest) {\n        xhr = new XMLHttpRequest();\n    } else {\n        xhr = new ActiveXObject('Microsoft.XMLHttp');\n    }\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4 && xhr.status == 200) {\n            console.log(2)\n            callback(xhr.responseText);\n        }\n    }\n\n    if (method == 'GET') {\n        var date = new Date(),\n        timer = date.getTime();\n        xhr.open('GET', url + '?' + data + '&timer' + timer, flag);\n        xhr.send()\n        } else if (method == 'POST') {\n        xhr.open('POST', url, flag);\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        xhr.send(data);\n    }\n}</pre>\n34、异步加载script\n<pre>function loadScript(url, callback) {\n    var oscript = document.createElement('script');\n    if (oscript.readyState) { // ie8及以下版本\n        oscript.onreadystatechange = function () {\n            if (oscript.readyState === 'complete' || oscript.readyState === 'loaded') {\n                callback();\n            }\n        }\n    } else {\n        oscript.onload = function () {\n            callback()\n        };\n    }\n    oscript.src = url;\n    document.body.appendChild(oscript);\n}</pre>\n35、cookie管理\n<pre>var cookie = {\n    set: function (name, value, time) {\n        document.cookie = name + '=' + value + '; max-age=' + time;\n        return this;\n    },\n    remove: function (name) {\n        return this.setCookie(name, '', -1);\n    },\n    get: function (name, callback) {\n        var allCookieArr = document.cookie.split('; ');\n        for (var i = 0; i < allCookieArr.length; i++) {\n            var itemCookieArr = allCookieArr[i].split('=');\n            if (itemCookieArr[0] === name) {\n                return itemCookieArr[1]\n            }\n        }\n        return undefined;\n    }\n}</pre>\n36、实现bind()方法\n<pre>Function.prototype.myBind = function (target) {\n    var target = target || window;\n    var _args1 = [].slice.call(arguments, 1);\n    var self = this;\n    var temp = function () {};\n    var F = function () {\n        var _args2 = [].slice.call(arguments, 0);\n        var parasArr = _args1.concat(_args2);\n        return self.apply(this instanceof temp ? this : target, parasArr)\n    }\n    temp.prototype = self.prototype;\n    F.prototype = new temp();\n    return F;\n}</pre>\n37、实现call()方法\n<pre>Function.prototype.myCall = function () {\n    var ctx = arguments[0] || window;\n    ctx.fn = this;\n    var args = [];\n    for (var i = 1; i < arguments.length; i++) {\n        args.push(arguments[i])\n    }\n    var result = ctx.fn(...args);\n    delete ctx.fn;\n    return result;\n}</pre>\n38、实现apply()方法\n<pre>Function.prototype.myApply = function () {\n    var ctx = arguments[0] || window;\n    ctx.fn = this;\n    if (!arguments[1]) {\n        var result = ctx.fn();\n        delete ctx.fn;\n        return result;\n    }\n    var result = ctx.fn(...arguments[1]);\n    delete ctx.fn;\n    return result;\n}</pre>\n39、防抖\n<pre>function debounce(handle, delay) {\n    var timer = null;\n    return function () {\n        var _self = this,\n            _args = arguments;\n        clearTimeout(timer);\n        timer = setTimeout(function () {\n            handle.apply(_self, _args)\n        }, delay)\n    }\n}</pre>\n40、节流\n<pre>function throttle(handler, wait) {\n    var lastTime = 0;\n    return function (e) {\n        var nowTime = new Date().getTime();\n        if (nowTime - lastTime > wait) {\n            handler.apply(this, arguments);\n            lastTime = nowTime;\n        }\n    }\n}</pre>\n41、requestAnimFrame兼容性方法\n<pre>window.requestAnimFrame = (function () {\n    return window.requestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        function (callback) {\n            window.setTimeout(callback, 1000 / 60);\n        };\n})();</pre>\n42、cancelAnimFrame兼容性方法\n<pre>window.cancelAnimFrame = (function () {\n    return window.cancelAnimationFrame ||\n        window.webkitCancelAnimationFrame ||\n        window.mozCancelAnimationFrame ||\n        function (id) {\n            window.clearTimeout(id);\n        };\n})();</pre>\n43、jsonp底层方法\n<pre>function jsonp(url, callback) {\n    var oscript = document.createElement('script');\n    if (oscript.readyState) { // ie8及以下版本\n        oscript.onreadystatechange = function () {\n            if (oscript.readyState === 'complete' || oscript.readyState === 'loaded') {\n                callback();\n            }\n        }\n    } else {\n        oscript.onload = function () {\n            callback()\n        };\n    }\n    oscript.src = url;\n    document.body.appendChild(oscript);\n}</pre>\n44、获取url上的参数\n<pre>function getUrlParam(sUrl, sKey) {\n    var result = {};\n    sUrl.replace(/(\\w+)=(\\w+)(?=[&|#])/g, function (ele, key, val) {\n        if (!result[key]) {\n            result[key] = val;\n        } else {\n            var temp = result[key];\n            result[key] = [].concat(temp, val);\n        }\n    })\n    if (!sKey) {\n        return result;\n    } else {\n        return result[sKey] || '';\n    }\n}</pre>\n45、格式化时间\n<pre>function formatDate(t, str) {\n    var obj = {\n        yyyy: t.getFullYear(),\n        yy: (\"\" + t.getFullYear()).slice(-2),\n        M: t.getMonth() + 1,\n        MM: (\"0\" + (t.getMonth() + 1)).slice(-2),\n        d: t.getDate(),\n        dd: (\"0\" + t.getDate()).slice(-2),\n        H: t.getHours(),\n        HH: (\"0\" + t.getHours()).slice(-2),\n        h: t.getHours() % 12,\n        hh: (\"0\" + t.getHours() % 12).slice(-2),\n        m: t.getMinutes(),\n        mm: (\"0\" + t.getMinutes()).slice(-2),\n        s: t.getSeconds(),\n        ss: (\"0\" + t.getSeconds()).slice(-2),\n        w: ['日', '一', '二', '三', '四', '五', '六'][t.getDay()]\n    };\n    return str.replace(/([a-z]+)/ig, function ($1) {\n        return obj[$1]\n    });\n}</pre>\n46、验证邮箱的正则表达式\n<pre>function isAvailableEmail(sEmail) {\n    var reg = /^([\\w+\\.])+@\\w+([.]\\w+)+$/\n    return reg.test(sEmail)\n}</pre>\n47、函数柯里化\n<pre>//是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术\n\nfunction curryIt(fn) {\n    var length = fn.length,\n        args = [];\n    var result = function (arg) {\n        args.push(arg);\n        length--;\n        if (length <= 0) {\n            return fn.apply(this, args);\n        } else {\n            return result;\n        }\n    }\n    return result;\n}</pre>\n48、大数相加\n<pre>function sumBigNumber(a, b) {\n    var res = '', //结果\n        temp = 0; //按位加的结果及进位\n    a = a.split('');\n    b = b.split('');\n    while (a.length || b.length || temp) {\n        //~~按位非 1.类型转换，转换成数字 2.~~undefined==0 \n        temp += ~~a.pop() + ~~b.pop();\n        res = (temp % 10) + res;\n        temp = temp > 9;\n    }\n    return res.replace(/^0+/, '');\n}</pre>\n49、单例模式\n<pre>function getSingle(func) {\n    var result;\n    return function () {\n        if (!result) {\n            result = new func(arguments);\n        }\n        return result;\n    }\n}</pre>","slug":"常用的JavaScript方法封装2","published":1,"date":"2022-05-17T08:27:46.374Z","updated":"2022-05-17T08:32:10.790Z","_id":"cl39w72ob0001tozs9itr0wl8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>time: 2020-05-18</p>\n<p>22、兼容getElementsByClassName方法</p>\n<pre>Element.prototype.getElementsByClassName = Document.prototype.getElementsByClassName = function (_className) {\n    var allDomArray = document.getElementsByTagName('*');\n    var lastDomArray = [];\n    function trimSpace(strClass) {\n        var reg = /\\s+/g;\n        return strClass.replace(reg, ' ').trim()\n    }\n    for (var i = 0; i < allDomArray.length; i++) {\n        var classArray = trimSpace(allDomArray[i].className).split(' ');\n        for (var j = 0; j < classArray.length; j++) {\n            if (classArray[j] == _className) {\n                lastDomArray.push(allDomArray[i]);\n                break;\n            }\n        }\n    }\n    return lastDomArray;\n}</pre>\n<p>23、运动函数</p>\n<pre>function animate(obj, json, callback) {\n    clearInterval(obj.timer);\n    var speed,\n        current;\n    obj.timer = setInterval(function () {\n        var lock = true;\n        for (var prop in json) {\n            if (prop == 'opacity') {\n                current = parseFloat(window.getComputedStyle(obj, null)[prop]) * 100;\n            } else {\n                current = parseInt(window.getComputedStyle(obj, null)[prop]);\n            }\n            speed = (json[prop] - current) / 7;\n            speed = speed > 0 ? Math.ceil(speed) : Math.floor(speed);\n\n            if (prop == 'opacity') {\n                obj.style[prop] = (current + speed) / 100;\n            } else {\n                obj.style[prop] = current + speed + 'px';\n            }\n            if (current != json[prop]) {\n                lock = false;\n            }\n        }\n        if (lock) {\n            clearInterval(obj.timer);\n            typeof callback == 'function' ? callback() : '';\n        }\n    }, 30)\n}</pre>\n<p>24、弹性运动</p>\n<pre>function ElasticMovement(obj, target) {\n    clearInterval(obj.timer);\n    var iSpeed = 40,\n        a, u = 0.8;\n    obj.timer = setInterval(function () {\n        a = (target - obj.offsetLeft) / 8;\n        iSpeed = iSpeed + a;\n        iSpeed = iSpeed * u;\n        if (Math.abs(iSpeed) <= 1 && Math.abs(a) <= 1) {\n            console.log('over')\n            clearInterval(obj.timer);\n            obj.style.left = target + 'px';\n        } else {\n            obj.style.left = obj.offsetLeft + iSpeed + 'px';\n        }\n    }, 30);\n}</pre>\n<p>25、封装自己的forEach方法</p>\n<pre>Array.prototype.myForEach = function (func, obj) {\n    var len = this.length;\n    var _this = arguments[1] ? arguments[1] : window;\n    // var _this=arguments[1]||window;\n    for (var i = 0; i < len; i++) {\n        func.call(_this, this[i], i, this)\n    }\n}</pre>\n<p>26、封装自己的filter方法</p>\n<pre>Array.prototype.myFilter = function (func, obj) {\n    var len = this.length;\n    var arr = [];\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        func.call(_this, this[i], i, this) && arr.push(this[i]);\n    }\n    return arr;\n}</pre>\n<p>27、数组map方法</p>\n<pre>Array.prototype.myMap = function (func) {\n    var arr = [];\n    var len = this.length;\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        arr.push(func.call(_this, this[i], i, this));\n    }\n    return arr;\n}</pre>\n<p>28、数组every方法</p>\n<pre>Array.prototype.myEvery = function (func) {\n    var flag = true;\n    var len = this.length;\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        if (func.apply(_this, [this[i], i, this]) == false) {\n            flag = false;\n            break;\n        }\n    }\n    return flag;\n}</pre>\n<p>29、数组reduce方法</p>\n<pre>Array.prototype.myReduce = function (func, initialValue) {\n    var len = this.length,\n        nextValue,\n        i;\n    if (!initialValue) {\n        // 没有传第二个参数\n        nextValue = this[0];\n        i = 1;\n    } else {\n        // 传了第二个参数\n        nextValue = initialValue;\n        i = 0;\n    }\n    for (; i < len; i++) {\n        nextValue = func(nextValue, this[i], i, this);\n    }\n    return nextValue;\n}</pre>\n<p>30、获取url中的参数</p>\n<pre>function getWindonHref() {\n    var sHref = window.location.href;\n    var args = sHref.split('?');\n    if (args[0] === sHref) {\n        return '';\n    }\n    var hrefarr = args[1].split('#')[0].split('&');\n    var obj = {};\n    for (var i = 0; i < hrefarr.length; i++) {\n        hrefarr[i] = hrefarr[i].split('=');\n        obj[hrefarr[i][0]] = hrefarr[i][1];\n    }\n    return obj;\n}</pre>\n<p>31、数组排序</p>\n<pre>// 快排 [left] + min + [right]\nfunction quickArr(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    var left = [],\n        right = [];\n    var pIndex = Math.floor(arr.length / 2);\n    var p = arr.splice(pIndex, 1)[0];\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] <= p) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    // 递归\n    return quickArr(left).concat([p], quickArr(right));\n}\n\n// 冒泡\nfunction bubbleSort(arr) {\n    for (var i = 0; i < arr.length - 1; i++) {\n        for (var j = i + 1; j < arr.length; j++) {\n            if (arr[i] > arr[j]) {\n                var temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\n\nfunction bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i < len - 1; i++) {\n        for (var j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                var temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n    return arr;\n}</pre>\n<p>32、遍历Dom树</p>\n<pre>// 给定页面上的DOM元素,将访问元素本身及其所有后代(不仅仅是它的直接子元素)\n// 对于每个访问的元素，函数讲元素传递给提供的回调函数\nfunction traverse(element, callback) {\n    callback(element);\n    var list = element.children;\n    for (var i = 0; i < list.length; i++) {\n        traverse(list[i], callback);\n    }\n}</pre>\n<p>33、原生js封装ajax</p>\n<pre>function ajax(method, url, callback, data, flag) {\n    var xhr;\n    flag = flag || true;\n    method = method.toUpperCase();\n    if (window.XMLHttpRequest) {\n        xhr = new XMLHttpRequest();\n    } else {\n        xhr = new ActiveXObject('Microsoft.XMLHttp');\n    }\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4 && xhr.status == 200) {\n            console.log(2)\n            callback(xhr.responseText);\n        }\n    }\n\n    if (method == 'GET') {\n        var date = new Date(),\n        timer = date.getTime();\n        xhr.open('GET', url + '?' + data + '&timer' + timer, flag);\n        xhr.send()\n        } else if (method == 'POST') {\n        xhr.open('POST', url, flag);\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        xhr.send(data);\n    }\n}</pre>\n<p>34、异步加载script</p>\n<pre>function loadScript(url, callback) {\n    var oscript = document.createElement('script');\n    if (oscript.readyState) { // ie8及以下版本\n        oscript.onreadystatechange = function () {\n            if (oscript.readyState === 'complete' || oscript.readyState === 'loaded') {\n                callback();\n            }\n        }\n    } else {\n        oscript.onload = function () {\n            callback()\n        };\n    }\n    oscript.src = url;\n    document.body.appendChild(oscript);\n}</pre>\n<p>35、cookie管理</p>\n<pre>var cookie = {\n    set: function (name, value, time) {\n        document.cookie = name + '=' + value + '; max-age=' + time;\n        return this;\n    },\n    remove: function (name) {\n        return this.setCookie(name, '', -1);\n    },\n    get: function (name, callback) {\n        var allCookieArr = document.cookie.split('; ');\n        for (var i = 0; i < allCookieArr.length; i++) {\n            var itemCookieArr = allCookieArr[i].split('=');\n            if (itemCookieArr[0] === name) {\n                return itemCookieArr[1]\n            }\n        }\n        return undefined;\n    }\n}</pre>\n<p>36、实现bind()方法</p>\n<pre>Function.prototype.myBind = function (target) {\n    var target = target || window;\n    var _args1 = [].slice.call(arguments, 1);\n    var self = this;\n    var temp = function () {};\n    var F = function () {\n        var _args2 = [].slice.call(arguments, 0);\n        var parasArr = _args1.concat(_args2);\n        return self.apply(this instanceof temp ? this : target, parasArr)\n    }\n    temp.prototype = self.prototype;\n    F.prototype = new temp();\n    return F;\n}</pre>\n<p>37、实现call()方法</p>\n<pre>Function.prototype.myCall = function () {\n    var ctx = arguments[0] || window;\n    ctx.fn = this;\n    var args = [];\n    for (var i = 1; i < arguments.length; i++) {\n        args.push(arguments[i])\n    }\n    var result = ctx.fn(...args);\n    delete ctx.fn;\n    return result;\n}</pre>\n<p>38、实现apply()方法</p>\n<pre>Function.prototype.myApply = function () {\n    var ctx = arguments[0] || window;\n    ctx.fn = this;\n    if (!arguments[1]) {\n        var result = ctx.fn();\n        delete ctx.fn;\n        return result;\n    }\n    var result = ctx.fn(...arguments[1]);\n    delete ctx.fn;\n    return result;\n}</pre>\n<p>39、防抖</p>\n<pre>function debounce(handle, delay) {\n    var timer = null;\n    return function () {\n        var _self = this,\n            _args = arguments;\n        clearTimeout(timer);\n        timer = setTimeout(function () {\n            handle.apply(_self, _args)\n        }, delay)\n    }\n}</pre>\n<p>40、节流</p>\n<pre>function throttle(handler, wait) {\n    var lastTime = 0;\n    return function (e) {\n        var nowTime = new Date().getTime();\n        if (nowTime - lastTime > wait) {\n            handler.apply(this, arguments);\n            lastTime = nowTime;\n        }\n    }\n}</pre>\n<p>41、requestAnimFrame兼容性方法</p>\n<pre>window.requestAnimFrame = (function () {\n    return window.requestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        function (callback) {\n            window.setTimeout(callback, 1000 / 60);\n        };\n})();</pre>\n<p>42、cancelAnimFrame兼容性方法</p>\n<pre>window.cancelAnimFrame = (function () {\n    return window.cancelAnimationFrame ||\n        window.webkitCancelAnimationFrame ||\n        window.mozCancelAnimationFrame ||\n        function (id) {\n            window.clearTimeout(id);\n        };\n})();</pre>\n<p>43、jsonp底层方法</p>\n<pre>function jsonp(url, callback) {\n    var oscript = document.createElement('script');\n    if (oscript.readyState) { // ie8及以下版本\n        oscript.onreadystatechange = function () {\n            if (oscript.readyState === 'complete' || oscript.readyState === 'loaded') {\n                callback();\n            }\n        }\n    } else {\n        oscript.onload = function () {\n            callback()\n        };\n    }\n    oscript.src = url;\n    document.body.appendChild(oscript);\n}</pre>\n<p>44、获取url上的参数</p>\n<pre>function getUrlParam(sUrl, sKey) {\n    var result = {};\n    sUrl.replace(/(\\w+)=(\\w+)(?=[&|#])/g, function (ele, key, val) {\n        if (!result[key]) {\n            result[key] = val;\n        } else {\n            var temp = result[key];\n            result[key] = [].concat(temp, val);\n        }\n    })\n    if (!sKey) {\n        return result;\n    } else {\n        return result[sKey] || '';\n    }\n}</pre>\n<p>45、格式化时间</p>\n<pre>function formatDate(t, str) {\n    var obj = {\n        yyyy: t.getFullYear(),\n        yy: (\"\" + t.getFullYear()).slice(-2),\n        M: t.getMonth() + 1,\n        MM: (\"0\" + (t.getMonth() + 1)).slice(-2),\n        d: t.getDate(),\n        dd: (\"0\" + t.getDate()).slice(-2),\n        H: t.getHours(),\n        HH: (\"0\" + t.getHours()).slice(-2),\n        h: t.getHours() % 12,\n        hh: (\"0\" + t.getHours() % 12).slice(-2),\n        m: t.getMinutes(),\n        mm: (\"0\" + t.getMinutes()).slice(-2),\n        s: t.getSeconds(),\n        ss: (\"0\" + t.getSeconds()).slice(-2),\n        w: ['日', '一', '二', '三', '四', '五', '六'][t.getDay()]\n    };\n    return str.replace(/([a-z]+)/ig, function ($1) {\n        return obj[$1]\n    });\n}</pre>\n<p>46、验证邮箱的正则表达式</p>\n<pre>function isAvailableEmail(sEmail) {\n    var reg = /^([\\w+\\.])+@\\w+([.]\\w+)+$/\n    return reg.test(sEmail)\n}</pre>\n<p>47、函数柯里化</p>\n<pre>//是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术\n\nfunction curryIt(fn) {\n    var length = fn.length,\n        args = [];\n    var result = function (arg) {\n        args.push(arg);\n        length--;\n        if (length <= 0) {\n            return fn.apply(this, args);\n        } else {\n            return result;\n        }\n    }\n    return result;\n}</pre>\n<p>48、大数相加</p>\n<pre>function sumBigNumber(a, b) {\n    var res = '', //结果\n        temp = 0; //按位加的结果及进位\n    a = a.split('');\n    b = b.split('');\n    while (a.length || b.length || temp) {\n        //~~按位非 1.类型转换，转换成数字 2.~~undefined==0 \n        temp += ~~a.pop() + ~~b.pop();\n        res = (temp % 10) + res;\n        temp = temp > 9;\n    }\n    return res.replace(/^0+/, '');\n}</pre>\n<p>49、单例模式</p>\n<pre>function getSingle(func) {\n    var result;\n    return function () {\n        if (!result) {\n            result = new func(arguments);\n        }\n        return result;\n    }\n}</pre>","site":{"data":{}},"excerpt":"","more":"<p>time: 2020-05-18</p>\n<p>22、兼容getElementsByClassName方法</p>\n<pre>Element.prototype.getElementsByClassName = Document.prototype.getElementsByClassName = function (_className) {\n    var allDomArray = document.getElementsByTagName('*');\n    var lastDomArray = [];\n    function trimSpace(strClass) {\n        var reg = /\\s+/g;\n        return strClass.replace(reg, ' ').trim()\n    }\n    for (var i = 0; i < allDomArray.length; i++) {\n        var classArray = trimSpace(allDomArray[i].className).split(' ');\n        for (var j = 0; j < classArray.length; j++) {\n            if (classArray[j] == _className) {\n                lastDomArray.push(allDomArray[i]);\n                break;\n            }\n        }\n    }\n    return lastDomArray;\n}</pre>\n<p>23、运动函数</p>\n<pre>function animate(obj, json, callback) {\n    clearInterval(obj.timer);\n    var speed,\n        current;\n    obj.timer = setInterval(function () {\n        var lock = true;\n        for (var prop in json) {\n            if (prop == 'opacity') {\n                current = parseFloat(window.getComputedStyle(obj, null)[prop]) * 100;\n            } else {\n                current = parseInt(window.getComputedStyle(obj, null)[prop]);\n            }\n            speed = (json[prop] - current) / 7;\n            speed = speed > 0 ? Math.ceil(speed) : Math.floor(speed);\n\n            if (prop == 'opacity') {\n                obj.style[prop] = (current + speed) / 100;\n            } else {\n                obj.style[prop] = current + speed + 'px';\n            }\n            if (current != json[prop]) {\n                lock = false;\n            }\n        }\n        if (lock) {\n            clearInterval(obj.timer);\n            typeof callback == 'function' ? callback() : '';\n        }\n    }, 30)\n}</pre>\n<p>24、弹性运动</p>\n<pre>function ElasticMovement(obj, target) {\n    clearInterval(obj.timer);\n    var iSpeed = 40,\n        a, u = 0.8;\n    obj.timer = setInterval(function () {\n        a = (target - obj.offsetLeft) / 8;\n        iSpeed = iSpeed + a;\n        iSpeed = iSpeed * u;\n        if (Math.abs(iSpeed) <= 1 && Math.abs(a) <= 1) {\n            console.log('over')\n            clearInterval(obj.timer);\n            obj.style.left = target + 'px';\n        } else {\n            obj.style.left = obj.offsetLeft + iSpeed + 'px';\n        }\n    }, 30);\n}</pre>\n<p>25、封装自己的forEach方法</p>\n<pre>Array.prototype.myForEach = function (func, obj) {\n    var len = this.length;\n    var _this = arguments[1] ? arguments[1] : window;\n    // var _this=arguments[1]||window;\n    for (var i = 0; i < len; i++) {\n        func.call(_this, this[i], i, this)\n    }\n}</pre>\n<p>26、封装自己的filter方法</p>\n<pre>Array.prototype.myFilter = function (func, obj) {\n    var len = this.length;\n    var arr = [];\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        func.call(_this, this[i], i, this) && arr.push(this[i]);\n    }\n    return arr;\n}</pre>\n<p>27、数组map方法</p>\n<pre>Array.prototype.myMap = function (func) {\n    var arr = [];\n    var len = this.length;\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        arr.push(func.call(_this, this[i], i, this));\n    }\n    return arr;\n}</pre>\n<p>28、数组every方法</p>\n<pre>Array.prototype.myEvery = function (func) {\n    var flag = true;\n    var len = this.length;\n    var _this = arguments[1] || window;\n    for (var i = 0; i < len; i++) {\n        if (func.apply(_this, [this[i], i, this]) == false) {\n            flag = false;\n            break;\n        }\n    }\n    return flag;\n}</pre>\n<p>29、数组reduce方法</p>\n<pre>Array.prototype.myReduce = function (func, initialValue) {\n    var len = this.length,\n        nextValue,\n        i;\n    if (!initialValue) {\n        // 没有传第二个参数\n        nextValue = this[0];\n        i = 1;\n    } else {\n        // 传了第二个参数\n        nextValue = initialValue;\n        i = 0;\n    }\n    for (; i < len; i++) {\n        nextValue = func(nextValue, this[i], i, this);\n    }\n    return nextValue;\n}</pre>\n<p>30、获取url中的参数</p>\n<pre>function getWindonHref() {\n    var sHref = window.location.href;\n    var args = sHref.split('?');\n    if (args[0] === sHref) {\n        return '';\n    }\n    var hrefarr = args[1].split('#')[0].split('&');\n    var obj = {};\n    for (var i = 0; i < hrefarr.length; i++) {\n        hrefarr[i] = hrefarr[i].split('=');\n        obj[hrefarr[i][0]] = hrefarr[i][1];\n    }\n    return obj;\n}</pre>\n<p>31、数组排序</p>\n<pre>// 快排 [left] + min + [right]\nfunction quickArr(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    var left = [],\n        right = [];\n    var pIndex = Math.floor(arr.length / 2);\n    var p = arr.splice(pIndex, 1)[0];\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] <= p) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    // 递归\n    return quickArr(left).concat([p], quickArr(right));\n}\n\n// 冒泡\nfunction bubbleSort(arr) {\n    for (var i = 0; i < arr.length - 1; i++) {\n        for (var j = i + 1; j < arr.length; j++) {\n            if (arr[i] > arr[j]) {\n                var temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\n\nfunction bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i < len - 1; i++) {\n        for (var j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                var temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n    return arr;\n}</pre>\n<p>32、遍历Dom树</p>\n<pre>// 给定页面上的DOM元素,将访问元素本身及其所有后代(不仅仅是它的直接子元素)\n// 对于每个访问的元素，函数讲元素传递给提供的回调函数\nfunction traverse(element, callback) {\n    callback(element);\n    var list = element.children;\n    for (var i = 0; i < list.length; i++) {\n        traverse(list[i], callback);\n    }\n}</pre>\n<p>33、原生js封装ajax</p>\n<pre>function ajax(method, url, callback, data, flag) {\n    var xhr;\n    flag = flag || true;\n    method = method.toUpperCase();\n    if (window.XMLHttpRequest) {\n        xhr = new XMLHttpRequest();\n    } else {\n        xhr = new ActiveXObject('Microsoft.XMLHttp');\n    }\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4 && xhr.status == 200) {\n            console.log(2)\n            callback(xhr.responseText);\n        }\n    }\n\n    if (method == 'GET') {\n        var date = new Date(),\n        timer = date.getTime();\n        xhr.open('GET', url + '?' + data + '&timer' + timer, flag);\n        xhr.send()\n        } else if (method == 'POST') {\n        xhr.open('POST', url, flag);\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        xhr.send(data);\n    }\n}</pre>\n<p>34、异步加载script</p>\n<pre>function loadScript(url, callback) {\n    var oscript = document.createElement('script');\n    if (oscript.readyState) { // ie8及以下版本\n        oscript.onreadystatechange = function () {\n            if (oscript.readyState === 'complete' || oscript.readyState === 'loaded') {\n                callback();\n            }\n        }\n    } else {\n        oscript.onload = function () {\n            callback()\n        };\n    }\n    oscript.src = url;\n    document.body.appendChild(oscript);\n}</pre>\n<p>35、cookie管理</p>\n<pre>var cookie = {\n    set: function (name, value, time) {\n        document.cookie = name + '=' + value + '; max-age=' + time;\n        return this;\n    },\n    remove: function (name) {\n        return this.setCookie(name, '', -1);\n    },\n    get: function (name, callback) {\n        var allCookieArr = document.cookie.split('; ');\n        for (var i = 0; i < allCookieArr.length; i++) {\n            var itemCookieArr = allCookieArr[i].split('=');\n            if (itemCookieArr[0] === name) {\n                return itemCookieArr[1]\n            }\n        }\n        return undefined;\n    }\n}</pre>\n<p>36、实现bind()方法</p>\n<pre>Function.prototype.myBind = function (target) {\n    var target = target || window;\n    var _args1 = [].slice.call(arguments, 1);\n    var self = this;\n    var temp = function () {};\n    var F = function () {\n        var _args2 = [].slice.call(arguments, 0);\n        var parasArr = _args1.concat(_args2);\n        return self.apply(this instanceof temp ? this : target, parasArr)\n    }\n    temp.prototype = self.prototype;\n    F.prototype = new temp();\n    return F;\n}</pre>\n<p>37、实现call()方法</p>\n<pre>Function.prototype.myCall = function () {\n    var ctx = arguments[0] || window;\n    ctx.fn = this;\n    var args = [];\n    for (var i = 1; i < arguments.length; i++) {\n        args.push(arguments[i])\n    }\n    var result = ctx.fn(...args);\n    delete ctx.fn;\n    return result;\n}</pre>\n<p>38、实现apply()方法</p>\n<pre>Function.prototype.myApply = function () {\n    var ctx = arguments[0] || window;\n    ctx.fn = this;\n    if (!arguments[1]) {\n        var result = ctx.fn();\n        delete ctx.fn;\n        return result;\n    }\n    var result = ctx.fn(...arguments[1]);\n    delete ctx.fn;\n    return result;\n}</pre>\n<p>39、防抖</p>\n<pre>function debounce(handle, delay) {\n    var timer = null;\n    return function () {\n        var _self = this,\n            _args = arguments;\n        clearTimeout(timer);\n        timer = setTimeout(function () {\n            handle.apply(_self, _args)\n        }, delay)\n    }\n}</pre>\n<p>40、节流</p>\n<pre>function throttle(handler, wait) {\n    var lastTime = 0;\n    return function (e) {\n        var nowTime = new Date().getTime();\n        if (nowTime - lastTime > wait) {\n            handler.apply(this, arguments);\n            lastTime = nowTime;\n        }\n    }\n}</pre>\n<p>41、requestAnimFrame兼容性方法</p>\n<pre>window.requestAnimFrame = (function () {\n    return window.requestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        function (callback) {\n            window.setTimeout(callback, 1000 / 60);\n        };\n})();</pre>\n<p>42、cancelAnimFrame兼容性方法</p>\n<pre>window.cancelAnimFrame = (function () {\n    return window.cancelAnimationFrame ||\n        window.webkitCancelAnimationFrame ||\n        window.mozCancelAnimationFrame ||\n        function (id) {\n            window.clearTimeout(id);\n        };\n})();</pre>\n<p>43、jsonp底层方法</p>\n<pre>function jsonp(url, callback) {\n    var oscript = document.createElement('script');\n    if (oscript.readyState) { // ie8及以下版本\n        oscript.onreadystatechange = function () {\n            if (oscript.readyState === 'complete' || oscript.readyState === 'loaded') {\n                callback();\n            }\n        }\n    } else {\n        oscript.onload = function () {\n            callback()\n        };\n    }\n    oscript.src = url;\n    document.body.appendChild(oscript);\n}</pre>\n<p>44、获取url上的参数</p>\n<pre>function getUrlParam(sUrl, sKey) {\n    var result = {};\n    sUrl.replace(/(\\w+)=(\\w+)(?=[&|#])/g, function (ele, key, val) {\n        if (!result[key]) {\n            result[key] = val;\n        } else {\n            var temp = result[key];\n            result[key] = [].concat(temp, val);\n        }\n    })\n    if (!sKey) {\n        return result;\n    } else {\n        return result[sKey] || '';\n    }\n}</pre>\n<p>45、格式化时间</p>\n<pre>function formatDate(t, str) {\n    var obj = {\n        yyyy: t.getFullYear(),\n        yy: (\"\" + t.getFullYear()).slice(-2),\n        M: t.getMonth() + 1,\n        MM: (\"0\" + (t.getMonth() + 1)).slice(-2),\n        d: t.getDate(),\n        dd: (\"0\" + t.getDate()).slice(-2),\n        H: t.getHours(),\n        HH: (\"0\" + t.getHours()).slice(-2),\n        h: t.getHours() % 12,\n        hh: (\"0\" + t.getHours() % 12).slice(-2),\n        m: t.getMinutes(),\n        mm: (\"0\" + t.getMinutes()).slice(-2),\n        s: t.getSeconds(),\n        ss: (\"0\" + t.getSeconds()).slice(-2),\n        w: ['日', '一', '二', '三', '四', '五', '六'][t.getDay()]\n    };\n    return str.replace(/([a-z]+)/ig, function ($1) {\n        return obj[$1]\n    });\n}</pre>\n<p>46、验证邮箱的正则表达式</p>\n<pre>function isAvailableEmail(sEmail) {\n    var reg = /^([\\w+\\.])+@\\w+([.]\\w+)+$/\n    return reg.test(sEmail)\n}</pre>\n<p>47、函数柯里化</p>\n<pre>//是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术\n\nfunction curryIt(fn) {\n    var length = fn.length,\n        args = [];\n    var result = function (arg) {\n        args.push(arg);\n        length--;\n        if (length <= 0) {\n            return fn.apply(this, args);\n        } else {\n            return result;\n        }\n    }\n    return result;\n}</pre>\n<p>48、大数相加</p>\n<pre>function sumBigNumber(a, b) {\n    var res = '', //结果\n        temp = 0; //按位加的结果及进位\n    a = a.split('');\n    b = b.split('');\n    while (a.length || b.length || temp) {\n        //~~按位非 1.类型转换，转换成数字 2.~~undefined==0 \n        temp += ~~a.pop() + ~~b.pop();\n        res = (temp % 10) + res;\n        temp = temp > 9;\n    }\n    return res.replace(/^0+/, '');\n}</pre>\n<p>49、单例模式</p>\n<pre>function getSingle(func) {\n    var result;\n    return function () {\n        if (!result) {\n            result = new func(arguments);\n        }\n        return result;\n    }\n}</pre>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}